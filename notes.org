* To do
** DONE Populate relations present in the import statement
   CLOSED: [2019-03-01 Fri 18:07]
Add to the relations that are referred by the parameters. The other approach is to erase the content of the existing relations. However, this latter approach is not monotonic and requires care during stratification.

Using different IDs for AST nodes from different programs to allow concatenation of programs without mixing AST nodes.
** DONE Pretty print the program
   CLOSED: [2019-03-01 Fri 18:17]
Add a pretty print implementation for the IMPORTLiteral AST node.

** DONE Implement a typechecker in DatalogM
   CLOSED: [2019-03-04 Mon 12:00]
The DatalogM engine typechecker is now disabled, so a new type checker written in Datalog is needed. The "!=" literal might be needed, which means that the signature of the IMPORT statement must be expanded to bring in representation of the logical and arithmetic expressions.

** DONE Use souffle for evaluation
   CLOSED: [2019-03-06 Wed 18:00]

** TODO Replace the typechecker in the DatalogM interpreted with the new one
** TODO Remove the TYPEOF special literal
** TODO Remove type constants

** TODO Introduce non-binding variable (i.e. _)
Allow the non-binding variable in negated atoms.

* Future changes
** TODO Non-referenceable built-in predicates: e.g. INPUT, OUTPUT, IMPORT, EXPORT, TYPEOF
- Disallow at grammar level.

* Questions
** Do we really need types?
- Can we replace types with strings?
- Update the TYPEOF predicate such that it does not use lists

** Can we write a datalog program that typechecks itself?
Yes. See [[examples/typecheck.in]].

** Add metavariables to improve the capability of Datalog to analyze itself
#+BEGIN_SRC prolog
IMPORT("file_path.mdl", 'Program).

analyze (Program) {

IsVarInPred($p, $x) :- [$p(...,$x,...)].

IsFact($p) :- [...,$p(...),... .].

IsNotGround($p) :- [$p(...,$x,...)],NEG(IsConstant($x)].

}

#+END_SRC

*** Analyze blocks ~analyze P { }~
The only blocks that are allowed to contain patterns, metavariables and gaps
- these blocks are desugared to plain Datalog relations
- all the patterns refer to the analyzed program ~P~

*** Patterns ~[$p(x, 1) :- ...,$q, ... .]~
- allows for matching rules, facts, predicates

*** Gaps: ~...~
Where do we need gaps?
In all variadic AST nodes. That are:
- literals: $p(...,$x,...)
- heads and bodies : [...,$p(a, b),... :- ...,$q(b, c),...],[... :- $p(a, b) ]

*** Metavariables: ~$x~, ~$p~
- terms: p($x, $y)
- predicates: $p(x, y)
- arithmetic expressions: $x + y
- literals: p(x, y) :- $l1, $l2,...
- enforce an order between metavariables:
  [$p(...,$x,...,$y,...)] implies that the term to which $x is bound comes before the term to which $y is bound.

*** Open questions:
- how do we attach an index to a metavariable: ~[$p(...,$i:$x,...,$j:$y,...,)]~
