import lang.cons.Constraint;
import java.util.TreeSet;
import java.util.HashSet;

aspect MetaLang {
	/**
	  enclosingPattern - return the enclosing pattern if it exists, otherwise null
	 */
	syn String ASTNode.varName() {
		String nodeNameFull = this.getClass().getName();
		String[] splitNodeName = nodeNameFull.split("\\.");
		String nodeName = splitNodeName[splitNodeName.length - 1];
		return "v_" + getNodeId() + "_" + nodeName;
	}

	/**
	   The asLiterals() equations are isomorphic to buildTupleWrapper()
	   equtions in the DatalogProject aspect. The common parts should be
	   factored out to ensure that the relational
	   representation of a program matches the code generated for a pattern.
	 */
	syn lang.ast.List<lang.ast.Literal> ASTNode.asLiterals();

	eq ASTNode.asLiterals() {
		lang.ast.List<lang.ast.Literal> literals = new lang.ast.List<>();

		int childIndex = 0;

		for (int i = 0; i < getNumChild(); ++i) {
			ASTNode child = getChild(i);
			if (child instanceof Opt)
				continue;
			lang.ast.List<lang.ast.Term> terms = new lang.ast.List<>();
			terms.add(new lang.ast.Variable(varName()));
			terms.add(new lang.ast.IntConstant("" + childIndex++));
			terms.add(new lang.ast.Variable(getChild(i).varName()));
			literals.add(new lang.ast.Atom(new lang.ast.PredicateSymbol(getScopePrefix() + getRelation()), terms));
		}
		return literals;
	}

	syn ArrayList<Constraint> List.constraints() {
		return new ArrayList<>();
		// if (getNumChild() == 0) {
		// 	return new ArrayList<>();
		// } else if (getChild(0).indexVarName() == null) {
		// 	// this list does not contain indexed elements
		// 	return new ArrayList<>();
		// }

		// ArrayList<Constraint> cons = new ArrayList<>();
		// ASTNode prevNonGap = null;
		// ASTNode prev = null;
		// boolean seenGap = false;

		// for (int i = 0; i < getNumChild(); ++i) {
		// 	ASTNode c = getChild(i);
		// 	if (!c.isGap()) {
		// 		if (!seenGap) {
		// 			// no gaps seen from the beginning, then the index variable
		// 			// is constrained to be equal to the position in the list
		// 			cons.add(Constraint.eq(c, i));
		// 		} else if (prev == prevNonGap) {
		// 			// seen gaps, but the predecessor is not a gap
		// 			// e.g. P(...,$i:t,$j:u,...) -> constrain $i + 1 == $j
		// 			cons.add(Constraint.next(prev, c));
		// 		} else if (prevNonGap != null) {
		// 			// seen gaps, but the predecessor is a gap
		// 			// e.g. P(...,$i:t,...,$j:u,...)
		// 			// There are two alternatives to chosse from:
		// 			// 1. constrain $j > $i
		// 			// 2. no constraint
		// 			// We choose to implement 2 to allow a pattern like
		// 			// ... :- ..., EQ(x, y), ..., $p(...),... . to cover cases
		// 			// where EQ comes before $p and after $p. If ordering is
		// 			// required, the user can add explicit indices.
		// 			cons.add(Constraint.member(c));
		// 		} else if (prevNonGap == null) {
		// 			// seens only gaps before
		// 			cons.add(Constraint.member(c));
		// 		}

		// 		if (i + 1 == getNumChild()) {
		// 			// this is the rightmost element in a list with gaps
		// 			// e.g. P(...,$i:t) -> constrain $i to be the index of the last element
		// 			cons.add(Constraint.last(c));
		// 		}
		// 	}

		// 	if (!c.isGap()) {
		// 		prevNonGap = c;
		// 	} else {
		// 		seenGap = true;
		// 	}
		// 	prev = c;
		// }
		// return cons;
	}

	syn ArrayList<lang.ast.Clause> List.clauses() {
		ArrayList<Constraint> cons = constraints();
		if (cons.isEmpty())
			return new ArrayList<>();
		ArrayList<lang.ast.Clause> clauses = new ArrayList<>();
		for (Constraint c : cons) {
			lang.ast.Clause cls = c.generateClause(getParent().getScopePrefix());
			if (cls != null)
				clauses.add(cls);
		}
		return clauses;
	}

	eq List.asLiterals() {
		ArrayList<Constraint> cons = constraints();
		if (cons.isEmpty())
			return super.asLiterals();

		lang.ast.List<lang.ast.Literal> lits = new lang.ast.List<>();
		for (Constraint c : cons)
			lits.addAll(c.generateLiterals(getScopePrefix()));
		return lits;
	}

	syn lang.ast.Constant Constant.constantValue();
	eq StringConstant.constantValue() = new lang.ast.StringConstant(getSTRING());
	eq IntConstant.constantValue() = new lang.ast.IntConstant(getNUMERAL());
	eq PredicateRef.constantValue() = new lang.ast.PredicateRef(getPRED_ID());

	eq Constant.asLiterals() {
		lang.ast.PredicateSymbol pred = new lang.ast.PredicateSymbol(getScopePrefix() + getRelation());
		lang.ast.List<lang.ast.Literal> literals = new lang.ast.List<>();
		lang.ast.List<lang.ast.Term> terms = new lang.ast.List<>();
		terms.add(new lang.ast.Variable(varName()));
		// remove the index if it exists
		Constant newConst = this.fullCopy();
		this.setIndexOpt(new Opt());
		terms.add(constantValue());
		literals.add(new lang.ast.Atom(pred, terms));
		return literals;
	}

	eq Variable.asLiterals() {
		lang.ast.PredicateSymbol pred = new lang.ast.PredicateSymbol(getScopePrefix() + getRelation());
		lang.ast.List<lang.ast.Literal> literals = new lang.ast.List<>();
		lang.ast.List<lang.ast.Term> terms = new lang.ast.List<>();
		terms.add(new lang.ast.Variable(varName()));
		terms.add(new lang.ast.StringConstant(this.getVAR_ID()));
		literals.add(new lang.ast.Atom(pred, terms));
		return literals;
	}

	eq PredicateSymbol.asLiterals() {
		lang.ast.PredicateSymbol pred = new lang.ast.PredicateSymbol(getScopePrefix() + getRelation());
		lang.ast.List<lang.ast.Literal> literals = new lang.ast.List<>();
		lang.ast.List<lang.ast.Term> terms = new lang.ast.List<>();
		terms.add(new lang.ast.Variable(varName()));
		terms.add(new lang.ast.StringConstant(this.getPRED_ID()));
		literals.add(new lang.ast.Atom(pred, terms));
		return literals;
	}

	eq FunctorSymbol.asLiterals() {
		lang.ast.PredicateSymbol pred = new lang.ast.PredicateSymbol(getScopePrefix() + getRelation());
		lang.ast.List<lang.ast.Literal> literals = new lang.ast.List<>();
		lang.ast.List<lang.ast.Term> terms = new lang.ast.List<>();
		terms.add(new lang.ast.Variable(varName()));
		terms.add(new lang.ast.StringConstant(getFUNC_ID()));
		literals.add(new lang.ast.Atom(pred, terms));
		return literals;
	}

	syn String ASTNode.indexVarName() = null;
	eq Term.indexVarName() {
		if (hasIndex())
			return getIndex().varName();
		return "i_" + getNodeId();
	}
	eq CommonLiteral.indexVarName() {
		if (hasIndex())
			return getIndex().varName();
		return "i_" + getNodeId();
	}

	syn boolean ASTNode.isGap() = false;
	eq LiteralGap.isGap() = true;
	eq TermGap.isGap() = true;

	eq MetaVariable.asLiterals() = new lang.ast.List<>();
	eq Opt.asLiterals() = new lang.ast.List<>();
	eq ClausePattern.asLiterals() = new lang.ast.List<>();
	eq MetaVariable.varName() = "mv_" + getMETAVAR_ID();

	// Collect all the literals resulting from a ClausePattern
	ASTNode contributes asLiterals() to ClausePattern.literals();
	coll lang.ast.List<lang.ast.CommonLiteral> ClausePattern.literals() with addAll root ClausePattern;
	coll ArrayList<lang.ast.Clause> AnalyzeBlock.clauses() with addAll root AnalyzeBlock;
	List contributes clauses() to AnalyzeBlock.clauses();

	syn nta Variable MetaVariable.getVariable() {
		return new Variable(varName());
	}

	syn String ASTNode.getScopePrefix() = getParent().getScopePrefix();
	eq Program.getScopePrefix() = "";
	eq AnalyzeBlock.getScopePrefix() = "A_" + getProgramRef().getPRED_ID() + "_";


	public lang.ast.Rule AnalyzeBlock.makeIdentifierRule(String name) {
		lang.ast.List<lang.ast.CommonLiteral> headList = new lang.ast.List<>();
		lang.ast.List<lang.ast.CommonLiteral> bodyList = new  lang.ast.List<>();

		lang.ast.List<lang.ast.Term> headVars = new lang.ast.List<>();
		headVars.add(new lang.ast.Variable("n_id"));
		headVars.add(new lang.ast.Variable("name"));
		lang.ast.CommonLiteral head = new lang.ast.Atom(new lang.ast.PredicateSymbol(getScopePrefix() + "ID"),
								headVars);
		lang.ast.CommonLiteral body = new lang.ast.Atom(new lang.ast.PredicateSymbol(getScopePrefix() + name),
									  headVars.fullCopy());

		headList.add(head);
		bodyList.add(body);

		return new lang.ast.Rule(headList, bodyList);
	}

	public lang.ast.Rule AnalyzeBlock.makeExprRule() {
		lang.ast.List<lang.ast.CommonLiteral> headList = new lang.ast.List<>();
		lang.ast.List<lang.ast.CommonLiteral> bodyList = new lang.ast.List<>();

		lang.ast.List<lang.ast.Term> headVars = new lang.ast.List<>();
		headVars.add(new lang.ast.Variable("n_id"));
		headVars.add(new lang.ast.Variable("j"));
		headVars.add(new lang.ast.Variable("child"));

		headList.add(new lang.ast.Atom(new lang.ast.PredicateSymbol(getScopePrefix() + "EXPR"),
					       headVars));

		lang.ast.List<lang.ast.Term> bodyVars1 = new lang.ast.List<>();
		bodyVars1.add(new lang.ast.Variable("n_id"));
		bodyVars1.add(new lang.ast.IntConstant("1"));
		bodyVars1.add(new lang.ast.Variable("l"));

		bodyList.add(new lang.ast.Atom(new lang.ast.PredicateSymbol(getScopePrefix() + "Functor"), bodyVars1));

		lang.ast.List<lang.ast.Term> bodyVars2 = new lang.ast.List<>();
		bodyVars2.add(new lang.ast.Variable("l"));
		bodyVars2.add(new lang.ast.Variable("j"));
		bodyVars2.add(new lang.ast.Variable("child"));

		bodyList.add(new lang.ast.Atom(new lang.ast.PredicateSymbol(getScopePrefix() + "Lst"), bodyVars2));

		return new lang.ast.Rule(headList, bodyList);
	}

	/**
	   For every analyze block, insert relations that provide the
	   context for evaluating the expanded patterns.
	 */
	public lang.ast.List<lang.ast.Clause> AnalyzeBlock.generateHelperRelations() {
		lang.ast.List<lang.ast.Clause> ret = new lang.ast.List<>();

		// Count the arity of the program relation
		int numVars = 0;
		for (ProgRelPart pr : IMPORTLiteral.programRelationStructure())
			numVars += pr.arity();

		// Project the wide program relation to relations matching the
		// node types
		int count = 0;
		for (ProgRelPart pr : IMPORTLiteral.programRelationStructure()) {
			// Build the head
			lang.ast.List<lang.ast.CommonLiteral> head = new lang.ast.List<>();
			lang.ast.List<lang.ast.Term> vars = new lang.ast.List<>();
			int firstVar = count;
			for (int i = 0; i < pr.defaultValue.arity(); ++i, ++count) {
				vars.add(new lang.ast.Variable("p" + count));
			}
			lang.ast.PredicateSymbol ps = new lang.ast.PredicateSymbol(getScopePrefix() + pr.name);
			head.add(new lang.ast.Atom(ps, vars));


			lang.ast.List<lang.ast.CommonLiteral> body = new lang.ast.List<>();
			lang.ast.List<lang.ast.Term> progVars = new lang.ast.List<>();
			for (int i = 0; i < numVars; ++i) {
				progVars.add(new lang.ast.Variable("p" + i));
			}

			lang.ast.PredicateSymbol progPS = new lang.ast.PredicateSymbol(getProgramRef().getPRED_ID());
			// Program(p0, ..., pN)
			body.add(new lang.ast.Atom(new lang.ast.PredicateSymbol(getProgramRef().getPRED_ID()),
						   progVars));

			// test for the node id to be greater than 0 to filter out any
			// possible dummy terms
			body.add(new lang.ast.GTLiteral(new lang.ast.PredicateSymbol("GT"),
							new lang.ast.Variable("p" + firstVar),
							new lang.ast.IntConstant("0")));

			ret.add(new lang.ast.Rule(head, body));
		}

		// Now create a clause containing a ground instance of the entire program relation
		// with false in the body, needed for type inference
		{
			lang.ast.List<lang.ast.CommonLiteral> head = new lang.ast.List<>();
			lang.ast.List<lang.ast.CommonLiteral> body = new lang.ast.List<>();
			lang.ast.List<lang.ast.Term> vars = new lang.ast.List<>();
			for (ProgRelPart pr : IMPORTLiteral.programRelationStructure()) {
				for (int i = 0; i < pr.defaultValue.arity(); ++i) {
					vars.add(pr.defaultValue.coord(i).fullCopy());
				}
			}

			head.add(new lang.ast.Atom(new lang.ast.PredicateSymbol(getProgramRef().getPRED_ID()), vars));
			body.add(new lang.ast.NEQLiteral(new lang.ast.PredicateSymbol("NEQ"),
							 new lang.ast.IntConstant("0"),
							 new lang.ast.IntConstant("0")));

			ret.add(new lang.ast.Rule(head, body));
		}

		// Add two new rules, to map variables and predicates to their predicates
		ret.add(makeIdentifierRule("Variable"));
		ret.add(makeIdentifierRule("PredicateSymbol"));
		ret.add(makeIdentifierRule("FunctorSymbol"));

		ret.add(makeExprRule());
		return ret;
	}

	// AnalyzeBlock contributes nta getAllClauses() to Program.predicateSymbols();
	// AnalyzeBlock contributes nta getAllClauses() to Program.pass1TypeMap();
}
