%class "LangParser";
%package "metalang.ast";

%embed {:
	static public class SyntaxError extends RuntimeException { public SyntaxError(String msg) {super(msg);}}
	// Disable syntax error recovery
	protected void recoverFromError(Symbol token, TokenStream in) {
		throw new SyntaxError("Cannot recover from the syntax error");
	}
:};

%terminals VAR_ID, METAVAR_ID, PRED_ID, PRED_REF, LPARA, RPARA, LBRACK, RBRACK, LBRACE, RBRACE, ELLIPSIS, COLON,
           NUMERAL, STRING, DOT, COMMA, IMPLIED_BY, EDB, OUTPUT, IMPORT, PRED,
           ATOM, NOT, BIND,  EQ, NEQ, LT, LTE, GT, GTE, ADD, SUB, MUL, DIV,
           TYPEOF, ANALYZE;

%typeof  program             =  "Program";
%typeof  clause              =  "CommonClause";
%typeof  inner_clause        =  "Clause";
%typeof  common_literal      =  "CommonLiteral";
%typeof  common_literal_opt_index = "CommonLiteral";
%typeof  literal             =  "Literal";
%typeof  bin_excl_term_lit   =  "BinaryExclusiveTermLiteral";
%typeof  bind_literal        =  "BINDLiteral";
%typeof  typeof_literal      =  "TYPEOFLiteral";
%typeof  edb_literal         =  "EDBLiteral";
%typeof  output_literal      =  "OUTPUTLiteral";
%typeof  pred_literal        =  "PREDLiteral";
%typeof  atom_literal        =  "ATOMLiteral";
%typeof  neg_literal         =  "NEGLiteral";
%typeof  eq_literal          =  "EQLiteral";
%typeof  neq_literal         =  "NEQLiteral";
%typeof  lt_literal          =  "LTLiteral";
%typeof  lte_literal         =  "LTELiteral";
%typeof  gt_literal          =  "GTLiteral";
%typeof  gte_literal         =  "GTELiteral";
%typeof  atom                =  "Atom";
%typeof  pred_sym            =  "PredicateSymbol";
%typeof  pred_ref            =  "PredicateRef";
%typeof  variable            =  "Variable";
%typeof  meta_variable       =  "MetaVariable";
%typeof  constant            =  "Constant";
%typeof  int_constant        =  "IntConstant";
%typeof  string_constant     =  "StringConstant";
%typeof  term                =  "Term";
%typeof  term_opt_index      =  "Term";
%typeof  term_list           =  "List";
%typeof  term_list_no_empty  =  "List";
%typeof  lit_list            =  "List";
%typeof  clause_list         =  "List";
%typeof  inner_clause_list   =  "List";
%typeof  fact                =  "Fact";
%typeof  rule                =  "Rule";
%typeof  expr                =  "Expr";
%typeof  expr_factor         =  "Expr";
%typeof  expr_term           =  "Expr";
%typeof  expr_unit           =  "Expr";
%typeof  expr_list           =  "List";
%typeof  expr_list_no_empty  =  "List";
%typeof  add_expr            =  "Functor";
%typeof  sub_expr            =  "Functor";
%typeof  mul_expr            =  "Functor";
%typeof  div_expr            =  "Functor";
%typeof  analyze_block       =  "AnalyzeBlock";
%typeof  clause_pattern      =  "ClausePattern";
%typeof  meta_atom           =  "MetaAtom";



%goal program;
%goal inner_clause;

program =  clause_list.list {: return new Program(list); :};

inner_clause_list = inner_clause.c {: return new List().add(c); :}
                  | inner_clause_list.list inner_clause.c {: return list.add(c); :}
                  ;

inner_clause = rule
             | fact
             ;

clause = inner_clause
       | analyze_block
       ;

clause_list = clause.c {: return new List().add(c); :}
            | clause_list.list clause.c {: return list.add(c); :}
            ;

analyze_block = ANALYZE LPARA pred_ref.prog_ref RPARA LBRACE inner_clause_list.list RBRACE {: return new AnalyzeBlock(prog_ref, list); :};

rule = lit_list.heads IMPLIED_BY lit_list.body DOT {: return new Rule(heads, body); :};
fact = lit_list.heads DOT {: return new Fact(heads); :};

common_literal_opt_index = common_literal
                         | meta_variable.mv COLON common_literal.l {: l.setIndex(mv); return l; :}
			 ;
common_literal = literal
               | meta_atom
               | clause_pattern
               ;

literal = gap_literal
        | edb_literal
        | output_literal
        | atom
        | typeof_literal
        | import_literal
        | neg_literal
        | bind_literal
        | bin_excl_term_lit
        | pred_literal
        | atom_literal
        ;

meta_atom = meta_variable.mv LPARA term_list.terms RPARA {: return new MetaAtom(mv, terms); :};
gap_literal = ELLIPSIS {: return new LiteralGap(); :};

clause_pattern = LBRACK inner_clause.c RBRACK {: return new ClausePattern(c); :};

neg_literal = NOT LPARA common_literal.lit RPARA {: return new NEGLiteral(new PredicateSymbol("NOT"), lit); :};

bind_literal = BIND LPARA variable.var COMMA expr.right RPARA {: return new BINDLiteral(new PredicateSymbol("BIND"), var, right); :}
             |  BIND LPARA meta_variable.var COMMA expr.right RPARA {: return new BINDLiteral(new PredicateSymbol("BIND"), var, right); :}
             ;

bin_excl_term_lit = eq_literal
                  | neq_literal
                  | lt_literal
                  | lte_literal
                  | gt_literal
                  | gte_literal
                  ;

eq_literal  = EQ  LPARA expr.left COMMA expr.right RPARA {: return new EQLiteral(new PredicateSymbol("EQ"),   left, right); :};
neq_literal = NEQ LPARA expr.left COMMA expr.right RPARA {: return new NEQLiteral(new PredicateSymbol("NEQ"), left, right); :};
lt_literal  = LT  LPARA expr.left COMMA expr.right RPARA {: return new LTLiteral(new PredicateSymbol("LT"),   left, right); :};
lte_literal = LTE LPARA expr.left COMMA expr.right RPARA {: return new LTELiteral(new PredicateSymbol("LTE"), left, right); :};
gt_literal  = GT  LPARA expr.left COMMA expr.right RPARA {: return new GTLiteral(new PredicateSymbol("GT"),   left, right); :};
gte_literal = GTE LPARA expr.left COMMA expr.right RPARA {: return new GTELiteral(new PredicateSymbol("GTE"), left, right); :};

atom = pred_sym.pred LPARA term_list.terms RPARA                      {: return new Atom(pred, terms); :};
edb_literal    = EDB    LPARA pred_ref.pred COMMA term.filelocs RPARA {: return new EDBLiteral(new PredicateSymbol("EDB"), pred, filelocs);  :};
output_literal = OUTPUT LPARA term.t RPARA                            {: return new OUTPUTLiteral(new PredicateSymbol("OUTPUT"), t);         :};
pred_literal   = PRED   LPARA term.t RPARA                            {: return new PREDLiteral(new PredicateSymbol("PRED"), t);             :};
atom_literal   = ATOM   LPARA term.t RPARA                            {: return new ATOMLiteral(new PredicateSymbol("ATOM"), t);             :};
typeof_literal = TYPEOF LPARA term.pred COMMA term.t RPARA            {: return new TYPEOFLiteral(new PredicateSymbol("TYPEOF"), pred, t);   :};
import_literal = IMPORT LPARA term.file_loc
                        COMMA pred_ref.program_ref
                        RPARA
     {: return new IMPORTLiteral(new PredicateSymbol("IMPORT"), file_loc, program_ref); :};

lit_list = common_literal_opt_index.lit {: return new List().add(lit); :}
         | lit_list.list COMMA common_literal_opt_index.c {: return list.add(c); :}
         ;

term_list = term_list_no_empty
          | /* epsilon */ {: return new List(); :}
          ;

term_list_no_empty = term_opt_index.t {: return new List().add(t); :}
                   | term_list_no_empty.list COMMA term_opt_index.t {: return list.add(t); :}
                   ;

expr = expr_term
     | functor
     ;

functor = VAR_ID.id LPARA expr_list.list RPARA {: return new Functor(new FunctorSymbol(id), list); :};
expr_list = expr_list_no_empty
          | /* epsilon */ {: return new List(); :}
          ;

expr_list_no_empty = expr.e {: return new List().add(e); :}
                   | expr_list_no_empty.list COMMA expr.e {: return list.add(e); :}
                   ;

expr_term   = add_expr
            | sub_expr
            | expr_factor
            ;

expr_factor = mul_expr
            | div_expr
            | expr_unit
            ;

expr_unit = term
              | LPARA expr.e RPARA {: return e; :}
              ;

add_expr = expr_term.e1   ADD expr_factor.e2 {: Functor f = new Functor(new FunctorSymbol("add"), new List<Expr>());
                                                f.addArg(e1); f.addArg(e2);
                                                return f; :};
sub_expr = expr_term.e1   SUB expr_factor.e2 {: Functor f = new Functor(new FunctorSymbol("sub"), new List<Expr>());
                                                f.addArg(e1); f.addArg(e2);
                                                return f; :};
mul_expr = expr_factor.e1 MUL expr_unit.e2 {: Functor f = new Functor(new FunctorSymbol("mul"), new List<Expr>());
                                                f.addArg(e1); f.addArg(e2);
                                                return f; :};
div_expr = expr_factor.e1 DIV expr_unit.e2 {: Functor f = new Functor(new FunctorSymbol("div"), new List<Expr>());
                                                f.addArg(e1); f.addArg(e2);
                                                return f; :};

term_opt_index = meta_variable.mv COLON term.t {: t.setIndex(mv); return t; :}
               | term
	       ;
term = variable
     | meta_variable
     | constant
     | pred_ref
     | term_gap
     ;

pred_sym = PRED_ID.id  {: return new PredicateSymbol((String)id.value); :};
pred_ref = PRED_REF.id {: return new PredicateRef((String)id.value); :};


meta_variable = METAVAR_ID.id {: return new MetaVariable((String)id.value); :};

variable = VAR_ID.id {: return new Variable((String)id.value); :};
constant = int_constant
         | string_constant
         ;

int_constant    = NUMERAL.num {: return new IntConstant((String)num.value); :};
string_constant = STRING.str {: return new StringConstant((String)str.value); :};

term_gap = ELLIPSIS {: return new TermGap(); :};
