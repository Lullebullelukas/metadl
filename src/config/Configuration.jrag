import lang.ast.Program;
import lang.ast.StandardPrettyPrinter;
import lang.ast.SoufflePrettyPrinter;
import lang.ast.FormalPredicate;
import lang.ast.Literal;
import lang.ast.PredicateRef;
import lang.ast.GlobalNames;
import lang.ast.StringConstant;
import lang.ast.IMPORTLiteral;
import lang.ast.TypeError;
import lang.ast.PredicateSymbol;
import lang.ast.IMPORTLiteral;
import lang.relation.PseudoTuple;
import lang.relation.Relation;
import lang.io.FileUtil;
import lang.io.CSVUtil;
import lang.io.SimpleLogger;
import lang.Compiler;
import lang.evaluation.BottomUpNaiveIterative;
import java.util.Set;
import java.util.HashSet;
import java.util.HashMap;
import java.util.Map;
import java.util.ArrayList;
import java.io.InputStreamReader;
import java.io.BufferedReader;
import java.io.FileReader;
import java.nio.file.Files;
import java.nio.file.StandardCopyOption;
import java.util.AbstractMap;
import org.apache.commons.lang3.time.StopWatch;
import org.apache.commons.lang3.mutable.MutableInt;

aspect Configuration {
    syn String Description.inputFile() = getInput().getPath();
    syn String Description.inputFileName() {
        return FileUtil.fileName(inputFile());
    }
    syn String Description.outputDir() = getTask().outputDir();
    syn String Description.factsDir() = getTask().factsDir();

    syn char Description.CSVSeparator() {
		String sep = getTask().CSVSeparator();
		if (sep.equals("\\t"))
			return '\t';
		return sep.charAt(0);
	}

    syn String Task.outputDir() {
        for(ConfigParam param : getParamss()) {
            if(param.isOutputDir())
                return FileUtil.normalize(((OutputDir) param).getPath());
        }
        return System.getProperty("user.dir");
    }

	syn String Task.CSVSeparator() {
		for (ConfigParam param : getParamss())
			if (param instanceof CSVSeparator)
				return ((CSVSeparator)param).getSeparator();
		return ",";
	}

    syn String Task.factsDir() {
        for(ConfigParam param : getParamss()) {
            if(param.isFactsDir())
                return FileUtil.normalize(((FactsDir) param).getPath());
        }
        return System.getProperty("user.dir");
    }

    syn boolean ConfigParam.isOutputDir()  = false;
    syn boolean OutputDir.isOutputDir()    = true;

    syn boolean ConfigParam.isFactsDir()   = false;
    syn boolean FactsDir.isFactsDir()      = true;
}

aspect SouffleConfiguration {
    syn boolean SouffleParam.isOutputFileName()   = false;
    syn boolean OutputFileName.isOutputFileName() = true;

    inh String SouffleTask.inputFileName();
    eq Description.getChild().inputFileName() = inputFileName();

    syn String SouffleTask.outputFileName() {
        for(SouffleParam param : getSouffleSpecificParamss()) {
            if(param.isOutputFileName())
                return ((OutputFileName) param).getName();
        }
        return FileUtil.changeExtension(inputFileName(), ".dl");
    }
}

aspect Task {
    public abstract Program Task.perform() throws Exception;
    inh Description Task.description();
    eq Description.getChild().description() = this;

    public Program Task.getProgramWithChecks() throws Exception {
        return getProgramWithChecks(description().getInput().getPath());
    }

    public Program Task.getProgramWithChecks(String path) throws Exception {
        Program program = (Program) FileUtil.parse(new File(path));
        Compiler.DrAST_root_node = program; // Enable debugging with DrAST
        new SemanticCheck(getParamss()).perform(program, description());
        new TypeCheck(getParamss()).perform(program, description());
        return program;
    }

	public void Task.generateObjectProgramRelations(Program program) throws Exception {
		// Add IMPORT to the formal predicate map. The facts produced by the IMPORT statement
		// will be exported in the generated souffle file.
		FormalPredicate formalImport = program.formalPredicateMap().get(GlobalNames.IMPORT_NAME);

		if (formalImport == null)
			return;

		// At least one IMPORT predicate used in the program, process it.

		// Define a time to measure the speed of the import
		StopWatch progRelTimer = StopWatch.createStarted();

		// map predicate name to program source files, to handle the case when multiple
		// files are imported to the same program relation.
		HashMap<String, ArrayList<Map.Entry<String, String>>> predicateSrcFiles = new HashMap<>();
		for (PredicateSymbol psym : formalImport.predicates()) {
			IMPORTLiteral imp = (IMPORTLiteral) psym.literal();
			String progFileLoc = ((StringConstant)imp.getFileLoc()).getSTRING();
			String lang = ((StringConstant)imp.getLang()).getSTRING();
			PredicateRef predref = (PredicateRef)(imp.getProgramRef());
			String predName = predref.getPRED_ID();

			ArrayList<Map.Entry<String, String>> files = predicateSrcFiles.get(predName);
			if (files != null) {
				files.add(new AbstractMap.SimpleEntry<String, String>(progFileLoc, lang));
			} else {
				files = new ArrayList<>();
				files.add(new AbstractMap.SimpleEntry<String, String>(progFileLoc, lang));
				predicateSrcFiles.put(predName, files);
			}
		}

		for (Map.Entry<String, ArrayList<Map.Entry<String, String>>> predicateSrcFile : predicateSrcFiles.entrySet()) {
			// exclude this file movement from the counting
			progRelTimer.suspend();

			String predName = predicateSrcFile.getKey();
			File output_fp = new File(factsDir() + "/" + predName + ".csv");

			MutableInt nodeCounter = new MutableInt(1);
			java.util.List<String> java5Srcs = new ArrayList<>();

			// include the program parse
			progRelTimer.resume();

			boolean append = false;
			for (Map.Entry<String, String> progFileLang : predicateSrcFile.getValue()) {
				Relation programRel = null;
				try {
					switch (progFileLang.getValue()) {
					case "metadl": {
						lang.metadl.obj.ast.Program prog = lang.metadl.obj.ast.Program.fromFileLoc(progFileLang.getKey());
						prog.assignIds(nodeCounter);
						programRel = prog.asRelation();
						break;
					}
					case "java4": {
						lang.java4.obj.ast.Program prog = lang.java4.obj.ast.Program.fromFileLoc(progFileLang.getKey());
						prog.assignIds(nodeCounter);
						programRel = prog.asRelation();
						break;
					}
					case "java7":
					case "java5": {
						java5Srcs.add(progFileLang.getKey());
						break;
					}
					default:
						SimpleLogger.logger().log("Unknown language to IMPORT: " + progFileLang.getValue(),
												  SimpleLogger.LogLevel.Level.ERROR);
						throw new RuntimeException("Unknown language to IMPORT");
					}
				} catch(Exception e) {
					SimpleLogger.logger().log("Could not open file for IMPORT: "
											  + progFileLang.getKey() + ", " + progFileLang.getValue() + "\n"
											  + e.toString(), SimpleLogger.LogLevel.Level.ERROR);
					throw new RuntimeException("Could not open file for IMPORT");
				}

				if (programRel != null) {
					CSVUtil.dumpFileInto(programRel, output_fp, append);
					append = true;
				}
			}

			if (!java5Srcs.isEmpty()) {
				// TODO: This assumes that all imports to this predicate are Java programs. This might
				// not be the case, but this should be checked in another place...
				Relation programRel = IMPORTLiteral.loadJavaSources(java5Srcs);
				CSVUtil.dumpFileInto(programRel, output_fp, false);
			}

			// stop the timer and report
			progRelTimer.stop();
		}

		SimpleLogger.logger().time("Evaluate IMPORT statements: " + progRelTimer.getTime() + "ms");
	}
}

aspect Import {
	public Program EvalImport.perform() throws Exception {
		Program program = getProgramWithChecks();
		generateObjectProgramRelations(program);
		return program;
	}
}

aspect Internal {
    public Program EvalBottomUpNaive.perform()  throws Exception {
        SimpleLogger.logger().log(description().debugInfo(), SimpleLogger.LogLevel.Level.DEBUG);
        Program program = getProgramWithChecks();
        BottomUpNaiveIterative bit = new BottomUpNaiveIterative();
        bit.evaluate(program, description());
        return program;
    }

    public Program PrettyBottomUpNaive.perform()  throws Exception {
        Program program = (Program) FileUtil.parse(new File(description().getInput().getPath()));
        Compiler.DrAST_root_node = program; // Enable debugging with DrAST
        StandardPrettyPrinter spp = new StandardPrettyPrinter<Program>(new PrintStream(System.out));
        spp.prettyPrint(program);
        return program;
    }
}

aspect Souffle {
	protected Program SouffleTask.preEvaluate() throws Exception {
		SimpleLogger.logger().log(description().debugInfo(), SimpleLogger.LogLevel.Level.DEBUG);

		Program program = getProgramWithChecks();

		generateObjectProgramRelations(program);

		return program;
    }

    protected void SouffleTask.postEvaluate() throws Exception {
    }

    public Program EvalSouffle.perform()  throws Exception {
        Program program;
        try {
            program = preEvaluate();
            String soufflePath = outputDir() + "/" + outputFileName();
            SimpleLogger.logger().log("PrettyPrint to: " + soufflePath, SimpleLogger.LogLevel.Level.DEBUG);

			StopWatch souffleGenTimer = StopWatch.createStarted();
            program.soufflePrint(new SoufflePrettyPrinter<Program>(new PrintStream(new FileOutputStream(new File(soufflePath)))));
			souffleGenTimer.stop();
			SimpleLogger.logger().time("Generate Souffle program: " + souffleGenTimer.getTime() + "ms");

			// Disable warnings in souffle
            String cmd = "souffle -w -D " + outputDir() + " " + soufflePath + " -F " + factsDir();
            SimpleLogger.logger().log("Run souffle with: " + cmd, SimpleLogger.LogLevel.Level.DEBUG);

			StopWatch souffleRunTimer = StopWatch.createStarted();
            Process p = Runtime.getRuntime().exec(cmd);

			BufferedReader brerr = new BufferedReader(new InputStreamReader(p.getErrorStream()));
			BufferedReader br = new BufferedReader(new InputStreamReader(p.getInputStream()));

			while (p.isAlive()) {
				while (brerr.ready())
					SimpleLogger.logger().log(":SOUFFLE-ERROR " + brerr.readLine(), SimpleLogger.LogLevel.Level.ERROR);
				while (br.ready())
					SimpleLogger.logger().log(":SOUFFLE-OUTPUT " + br.readLine(), SimpleLogger.LogLevel.Level.DEBUG);
			}

			p.waitFor();
			souffleRunTimer.stop();
			SimpleLogger.logger().time("Run Souffle program: " + souffleRunTimer.getTime() + "ms");

            br.close();
            brerr.close();
        } finally {
            postEvaluate();
        }

        return program;
    }

    public Program PrettySouffle.perform()  throws Exception{
        Program program;
        try {
            program = preEvaluate();
            String soufflePath = outputDir() + "/" + outputFileName();
            SimpleLogger.logger().log("PrettyPrint to: " + soufflePath, SimpleLogger.LogLevel.Level.DEBUG);

			StopWatch souffleGenTimer = StopWatch.createStarted();
            program.soufflePrint(new SoufflePrettyPrinter<Program>(new PrintStream(new FileOutputStream(new File(soufflePath)))));
			souffleGenTimer.stop();
			SimpleLogger.logger().time("Generate Souffle program: " + souffleGenTimer.getTime() + "ms");
        } finally {
            postEvaluate();
        }
        return program;
    }
}

aspect SubTask {
    public Program SemanticCheck.perform()  throws Exception {
        Program program = (Program) FileUtil.parse(new File(description().getInput().getPath()));
        Compiler.DrAST_root_node = program; // Enable debugging with DrAST
        perform(program, description());
        return program;
    }

    public Program TypeCheck.perform() throws Exception {
        Program program = (Program) FileUtil.parse(new File(description().getInput().getPath()));
        Compiler.DrAST_root_node = program; // Enable debugging with DrAST
        perform(program, description());
        return program;
    }

    public interface SubTask {
        void perform(Program program, Description descr) throws Exception;
    }

    TypeCheck        implements SubTask;
    SemanticCheck    implements SubTask;

    public void TypeCheck.perform(Program program, Description descr) {
		if (program.typeErrors().isEmpty())
			return;

		StringBuffer typeErrs = new StringBuffer();
		for (TypeError e : program.typeErrors())
			typeErrs.append(e.reportPosition() + "\n");

		SimpleLogger.logger().log("Compilation failed with type errors: \n" + typeErrs.toString(), SimpleLogger.LogLevel.Level.ERROR);
		throw new RuntimeException("Compilation failed with type errors.");
    }

    public void SemanticCheck.perform(Program program, Description descr) throws Exception {
        if(!program.hasSemanticErrors())
			return;
        SimpleLogger.logger().log("Compilation failed with semantic error: \n" + program.errorReport(), SimpleLogger.LogLevel.Level.ERROR);
		throw new RuntimeException("Compilation failed with semantic errors.");
    }
}
