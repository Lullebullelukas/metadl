import lang.ast.Program;
import lang.ast.StandardPrettyPrinter;
import lang.ast.SoufflePrettyPrinter;
import lang.ast.FormalPredicate;
import lang.ast.Literal;
import lang.ast.PredicateRef;
import lang.ast.GlobalNames;
import lang.ast.StringConstant;
import lang.ast.TypeError;
import lang.ast.PredicateSymbol;
import lang.relation.PseudoTuple;
import lang.relation.Relation;
import lang.io.FileUtil;
import lang.io.CSVUtil;
import lang.io.SimpleLogger;
import lang.Compiler;
import java.util.Set;
import java.util.HashSet;
import java.util.HashMap;
import java.util.Map;
import java.util.ArrayList;
import java.io.InputStreamReader;
import java.io.BufferedReader;
import java.io.FileReader;
import java.nio.file.Files;
import java.nio.file.StandardCopyOption;
import java.util.AbstractMap;
import org.apache.commons.lang3.time.StopWatch;
import org.apache.commons.lang3.mutable.MutableInt;
import lang.CmdLineOpts;

aspect Configuration {
	syn String Description.inputFile() = getInput().getPath();
	syn String Description.inputFileName() {
		return FileUtil.fileName(inputFile());
	}
	syn String Description.outputDir() = getTask().outputDir();
	syn String Description.factsDir() = getTask().factsDir();

	syn char Description.CSVSeparator() {
		String sep = getTask().CSVSeparator();
		if (sep.equals("\\t"))
			return '\t';
		return sep.charAt(0);
	}

	syn String Task.outputDir() {
		for(ConfigParam param : getParamss()) {
			if(param.isOutputDir())
				return FileUtil.normalize(((OutputDir) param).getPath());
		}
		return System.getProperty("user.dir");
	}

	syn String Task.CSVSeparator() {
		for (ConfigParam param : getParamss())
			if (param instanceof CSVSeparator)
				return ((CSVSeparator)param).getSeparator();
		return ",";
	}

	syn String Task.factsDir() {
		for(ConfigParam param : getParamss()) {
			if(param.isFactsDir())
				return FileUtil.normalize(((FactsDir) param).getPath());
		}
		return System.getProperty("user.dir");
	}

	syn boolean ConfigParam.isOutputDir()  = false;
	syn boolean OutputDir.isOutputDir()	   = true;

	syn boolean ConfigParam.isFactsDir()   = false;
	syn boolean FactsDir.isFactsDir()	   = true;
}

aspect SouffleConfiguration {
	syn boolean SouffleParam.isOutputFileName()	  = false;
	syn boolean OutputFileName.isOutputFileName() = true;

	inh String SouffleTask.inputFileName();
	eq Description.getChild().inputFileName() = inputFileName();

	syn String SouffleTask.outputFileName() {
		for(SouffleParam param : getSouffleSpecificParamss()) {
			if(param.isOutputFileName())
				return ((OutputFileName) param).getName();
		}
		return FileUtil.changeExtension(inputFileName(), ".dl");
	}
}

aspect Task {
	public abstract Program Task.perform() throws Exception;
	inh Description Task.description();
	eq Description.getChild().description() = this;

	public Program Task.getProgramWithChecks() throws Exception {
		return getProgramWithChecks(description().getInput().getPath());
	}

	public Program Task.getProgramWithChecks(String path) throws Exception {
		Program program = (Program) FileUtil.parse(new File(path));
		Compiler.DrAST_root_node = program; // Enable debugging with DrAST
		new SemanticCheck(getParamss()).perform(program, description());
		new TypeCheck(getParamss()).perform(program, description());


		/// Export the PDG
		try {
			program.predicateDependencyGraph().dump();
			program.dumpStrata();
		} catch (IOException e) {
		}
		///

		return program;
	}

	public void Task.generateObjectProgramRelations(Program program) throws Exception {
		// Start a timer to measure the speed of the import
		StopWatch progRelTimer = StopWatch.createStarted();

		program.evalIMPORT(program.evalCtx());

		FormalPredicate formalImport = program.formalPredicateMap().get(GlobalNames.IMPORT_NAME);
		if (formalImport == null)
			return;

		for (PredicateSymbol psym : formalImport.predicates()) {
			Literal imp = psym.parentLiteral();
			String progFileLoc = ((StringConstant)imp.getTerms(1)).getSTRING();
			String lang = ((StringConstant)imp.getTerms(2)).getSTRING();
			PredicateRef predref = (PredicateRef)(imp.getTerms(0));
			FormalPredicate formalProg = predref.formalpredicate();
			String predName = predref.getPRED_ID();

			CSVUtil.writeRelation(program.evalCtx(), formalProg.type(), formalProg.relation2(),
								  CmdLineOpts.getFactsDir() + "/" + predName + ".csv");
		}

		// stop the timer and report
		progRelTimer.stop();
		SimpleLogger.logger().time("Evaluate IMPORT statements: " + progRelTimer.getTime() + "ms");
	}
}

aspect Import {
	public Program EvalImport.perform() throws Exception {
		Program program = getProgramWithChecks();
		CmdLineOpts.setOutputDir(outputDir());
		CmdLineOpts.setFactsDir(factsDir());
		generateObjectProgramRelations(program);
		return program;
	}
}

aspect Internal {
	public Program EvalBottomUpNaive.perform()	throws Exception {
		CmdLineOpts.setOutputDir(outputDir());
		CmdLineOpts.setFactsDir(factsDir());
		SimpleLogger.logger().log(description().debugInfo(), SimpleLogger.LogLevel.Level.DEBUG);
		Program program = getProgramWithChecks();
		try {
			program.eval();
		} catch (IOException e) {
			throw new RuntimeException(e);
		}
		return program;
	}

	public Program PrettyBottomUpNaive.perform()  throws Exception {
		Program program = (Program) FileUtil.parse(new File(description().getInput().getPath()));
		Compiler.DrAST_root_node = program; // Enable debugging with DrAST
		StandardPrettyPrinter spp = new StandardPrettyPrinter<Program>(new PrintStream(System.out));
		spp.prettyPrint(program);
		return program;
	}
}

aspect Souffle {
	protected Program SouffleTask.preEvaluate() throws Exception {
		CmdLineOpts.setOutputDir(outputDir());
		CmdLineOpts.setFactsDir(factsDir());

		SimpleLogger.logger().log(description().debugInfo(), SimpleLogger.LogLevel.Level.DEBUG);

		Program program = getProgramWithChecks();
		generateObjectProgramRelations(program);

		return program;
	}


	public Program EvalSouffle.perform()  throws Exception {
		Program program;
		try {
			program = preEvaluate();
			String soufflePath = outputDir() + "/" + outputFileName();
			SimpleLogger.logger().log("PrettyPrint to: " + soufflePath, SimpleLogger.LogLevel.Level.DEBUG);

			StopWatch souffleGenTimer = StopWatch.createStarted();
			program.soufflePrint(new SoufflePrettyPrinter<Program>(new PrintStream(new FileOutputStream(new File(soufflePath)))));
			souffleGenTimer.stop();
			SimpleLogger.logger().time("Generate Souffle program: " + souffleGenTimer.getTime() + "ms");

			// Disable warnings in souffle
			String cmd = "souffle -w -D " + outputDir() + " " + soufflePath + " -F " + factsDir();
			SimpleLogger.logger().log("Run souffle with: " + cmd, SimpleLogger.LogLevel.Level.DEBUG);

			StopWatch souffleRunTimer = StopWatch.createStarted();
			Process p = Runtime.getRuntime().exec(cmd);

			BufferedReader brerr = new BufferedReader(new InputStreamReader(p.getErrorStream()));
			BufferedReader br = new BufferedReader(new InputStreamReader(p.getInputStream()));

			while (p.isAlive()) {
				while (brerr.ready())
					SimpleLogger.logger().log(":SOUFFLE-ERROR " + brerr.readLine(), SimpleLogger.LogLevel.Level.ERROR);
				while (br.ready())
					SimpleLogger.logger().log(":SOUFFLE-OUTPUT " + br.readLine(), SimpleLogger.LogLevel.Level.DEBUG);
			}

			p.waitFor();
			souffleRunTimer.stop();
			SimpleLogger.logger().time("Run Souffle program: " + souffleRunTimer.getTime() + "ms");

			br.close();
			brerr.close();
		} finally {
		}

		return program;
	}

	public Program PrettySouffle.perform()	throws Exception{
		Program program;
		try {
			program = preEvaluate();
			String soufflePath = outputDir() + "/" + outputFileName();
			SimpleLogger.logger().log("PrettyPrint to: " + soufflePath, SimpleLogger.LogLevel.Level.DEBUG);

			StopWatch souffleGenTimer = StopWatch.createStarted();
			program.soufflePrint(new SoufflePrettyPrinter<Program>(new PrintStream(new FileOutputStream(new File(soufflePath)))));
			souffleGenTimer.stop();
			SimpleLogger.logger().time("Generate Souffle program: " + souffleGenTimer.getTime() + "ms");
		} finally {
		}
		return program;
	}
}

aspect SubTask {
	public Program SemanticCheck.perform()	throws Exception {
		Program program = (Program) FileUtil.parse(new File(description().getInput().getPath()));
		Compiler.DrAST_root_node = program; // Enable debugging with DrAST
		perform(program, description());
		return program;
	}

	public Program TypeCheck.perform() throws Exception {
		Program program = (Program) FileUtil.parse(new File(description().getInput().getPath()));
		Compiler.DrAST_root_node = program; // Enable debugging with DrAST
		perform(program, description());
		return program;
	}

	public interface SubTask {
		void perform(Program program, Description descr) throws Exception;
	}

	TypeCheck		 implements SubTask;
	SemanticCheck	 implements SubTask;

	public void TypeCheck.perform(Program program, Description descr) {
		if (program.typeErrors().isEmpty())
			return;

		StringBuffer typeErrs = new StringBuffer();
		for (TypeError e : program.typeErrors())
			typeErrs.append(e.reportPosition() + "\n");

		SimpleLogger.logger().log("Compilation failed with type errors: \n" + typeErrs.toString(), SimpleLogger.LogLevel.Level.ERROR);
		throw new RuntimeException("Compilation failed with type errors.");
	}

	public void SemanticCheck.perform(Program program, Description descr) throws Exception {
		if(!program.hasSemanticErrors())
			return;
		SimpleLogger.logger().log("Compilation failed with semantic error: \n" + program.errorReport(), SimpleLogger.LogLevel.Level.ERROR);
		throw new RuntimeException("Compilation failed with semantic errors.");
	}
}
