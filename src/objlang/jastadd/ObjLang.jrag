// import lang.cons.Constraint;
// import java.util.TreeSet;
// import java.util.HashSet;
// import java.util.Collections;
// import lang.ast.AnalyzeContext;
// import lang.cons.ObjLangASTNode;

// aspect Pattern {
// 	/**
// 	   Attributes that implement the MetaVariableTraits interface
// 	 */
// 	syn String ASTNode.varName() {
// 		String nodeNameFull = this.getClass().getName();
// 		String[] splitNodeName = nodeNameFull.split("\\.");
// 		String nodeName = splitNodeName[splitNodeName.length - 1];
// 		return "v_" + getNodeId() + "_" + nodeName;
// 	}

// 	/**
// 	   The asLiterals() equations are isomorphic to buildTupleWrapper()
// 	   equtions in the DatalogProject aspect. The common parts should be
// 	   factored out to ensure that the relational
// 	   representation of a program matches the code generated for a pattern.
// 	 */
// 	syn ArrayList<lang.ast.Literal> ASTNode.asLiterals(String scopePrefix);

// 	eq ASTNode.asLiterals(String scopePrefix) {
// 		ArrayList<lang.ast.Literal> literals = new ArrayList<>();

// 		int childIndex = 0;

// 		for (int i = 0; i < getNumChild(); ++i) {
// 			ASTNode child = getChild(i);
// 			if (child instanceof Opt)
// 				continue;
// 			lang.ast.List<lang.ast.Term> terms = new lang.ast.List<>();
// 			terms.add(new lang.ast.Variable(varName()));
// 			terms.add(new lang.ast.IntConstant("" + childIndex++));
// 			terms.add(new lang.ast.Variable(getChild(i).varName()));
// 			literals.add(new lang.ast.Atom(new lang.ast.PredicateSymbol(scopePrefix + getRelation()), terms));
// 		}
// 		return literals;
// 	}

// 	ASTNode implements ObjLangASTNode;

// 	syn ArrayList<Constraint> List.constraints() {
// 		if (getNumChild() == 0) {
// 			return new ArrayList<>();
// 		} else if (getChild(0).indexVarName() == null) {
// 			// this list does not contain indexed elements
// 			return new ArrayList<>();
// 		}

// 		ArrayList<Constraint> cons = new ArrayList<>();
// 		ASTNode prevNonGap = null;
// 		ASTNode prev = null;
// 		boolean seenGap = false;

// 		for (int i = 0; i < getNumChild(); ++i) {
// 			ASTNode c = getChild(i);
// 			if (!c.isGap()) {
// 				if (!seenGap) {
// 					// no gaps seen from the beginning, then the index variable
// 					// is constrained to be equal to the position in the list
// 					cons.add(Constraint.eq(c, i));
// 				} else if (prev == prevNonGap) {
// 					// seen gaps, but the predecessor is not a gap
// 					// e.g. P(...,$i:t,$j:u,...) -> constrain $i + 1 == $j
// 					cons.add(Constraint.next(prev, c));
// 				} else if (prevNonGap != null) {
// 					// seen gaps, but the predecessor is a gap
// 					// e.g. P(...,$i:t,...,$j:u,...)
// 					// There are two alternatives to chosse from:
// 					// 1. constrain $j > $i
// 					// 2. no constraint
// 					// We choose to implement 2 to allow a pattern like
// 					// ... :- ..., EQ(x, y), ..., $p(...),... . to cover cases
// 					// where EQ comes before $p and after $p. If ordering is
// 					// required, the user can add explicit indices.
// 					cons.add(Constraint.member(c));
// 				} else if (prevNonGap == null) {
// 					// seens only gaps before
// 					cons.add(Constraint.member(c));
// 				}

// 				if (i + 1 == getNumChild()) {
// 					// this is the rightmost element in a list with gaps
// 					// e.g. P(...,$i:t) -> constrain $i to be the index of the last element
// 					cons.add(Constraint.last(c));
// 				}
// 			}

// 			if (!c.isGap()) {
// 				prevNonGap = c;
// 			} else {
// 				seenGap = true;
// 			}
// 			prev = c;
// 		}
// 		return cons;
// 	}

// 	syn ArrayList<lang.ast.Clause> ASTNode.asClauses(String scopePrefix) = new ArrayList<>();
// 	eq List.asClauses(String scopePrefix) {
// 		ArrayList<Constraint> cons = constraints();
// 		if (cons.isEmpty())
// 			return new ArrayList<>();
// 		ArrayList<lang.ast.Clause> clauses = new ArrayList<>();
// 		for (Constraint c : cons) {
// 			lang.ast.Clause cls = c.generateClause(new AnalyzeContext(scopePrefix, ""));
// 			if (cls != null)
// 				clauses.add(cls);
// 		}
// 		return clauses;
// 	}

// 	eq List.asLiterals(String scopePrefix) {
// 		ArrayList<Constraint> cons = constraints();
// 		if (cons.isEmpty())
// 			return super.asLiterals(scopePrefix);

// 		ArrayList<lang.ast.Literal> lits = new ArrayList<>();
// 		for (Constraint c : cons)
// 			lits.addAll(c.generateLiterals(new AnalyzeContext(scopePrefix, "")));
// 		return lits;
// 	}

// 	syn lang.ast.Constant Constant.constantValue();
// 	eq StringConstant.constantValue() = new lang.ast.StringConstant(getSTRING());
// 	eq IntConstant.constantValue() = new lang.ast.IntConstant(getNUMERAL());
// 	eq PredicateRef.constantValue() = new lang.ast.PredicateRef(getPRED_ID());

// 	eq Constant.asLiterals(String scopePrefix) {
// 		lang.ast.PredicateSymbol pred = new lang.ast.PredicateSymbol(scopePrefix + getRelation());
// 		ArrayList<lang.ast.Literal> literals = new ArrayList<>();
// 		lang.ast.List<lang.ast.Term> terms = new lang.ast.List<>();
// 		terms.add(new lang.ast.Variable(varName()));
// 		// remove the index if it exists
// 		Constant newConst = this.treeCopyNoTransform();
// 		this.setIndexOpt(new Opt());
// 		terms.add(constantValue());
// 		literals.add(new lang.ast.Atom(pred, terms));
// 		return literals;
// 	}

// 	eq Variable.asLiterals(String scopePrefix) {
// 		lang.ast.PredicateSymbol pred = new lang.ast.PredicateSymbol(scopePrefix + getRelation());
// 		ArrayList<lang.ast.Literal> literals = new ArrayList<>();
// 		lang.ast.List<lang.ast.Term> terms = new lang.ast.List<>();
// 		terms.add(new lang.ast.Variable(varName()));
// 		terms.add(new lang.ast.StringConstant(this.getVAR_ID()));
// 		literals.add(new lang.ast.Atom(pred, terms));
// 		return literals;
// 	}

// 	eq PredicateSymbol.asLiterals(String scopePrefix) {
// 		lang.ast.PredicateSymbol pred = new lang.ast.PredicateSymbol(scopePrefix + getRelation());
// 		ArrayList<lang.ast.Literal> literals = new ArrayList<>();
// 		lang.ast.List<lang.ast.Term> terms = new lang.ast.List<>();
// 		terms.add(new lang.ast.Variable(varName()));
// 		terms.add(new lang.ast.StringConstant(this.getPRED_ID()));
// 		literals.add(new lang.ast.Atom(pred, terms));
// 		return literals;
// 	}

// 	eq FunctorSymbol.asLiterals(String scopePrefix) {
// 		lang.ast.PredicateSymbol pred = new lang.ast.PredicateSymbol(scopePrefix + getRelation());
// 		ArrayList<lang.ast.Literal> literals = new ArrayList<>();
// 		lang.ast.List<lang.ast.Term> terms = new lang.ast.List<>();
// 		terms.add(new lang.ast.Variable(varName()));
// 		terms.add(new lang.ast.StringConstant(getFUNC_ID()));
// 		literals.add(new lang.ast.Atom(pred, terms));
// 		return literals;
// 	}

// 	syn String ASTNode.indexVarName() = null;
// 	eq Term.indexVarName() {
// 		if (hasIndex())
// 			return getIndex().varName();
// 		return "i_" + getNodeId();
// 	}
// 	eq CommonLiteral.indexVarName() {
// 		if (hasIndex())
// 			return getIndex().varName();
// 		return "i_" + getNodeId();
// 	}

// 	eq Opt.asLiterals(String scopePrefix) = new ArrayList<>();

// 	syn ArrayList<lang.ast.Literal> ASTNode.literals(String scopePrefix) {
// 		// An add-hoc way of implementing parameterized collection attributes
// 		ArrayList<lang.ast.Literal> list = new ArrayList<>();
// 		list.addAll(asLiterals(scopePrefix));
// 		for (ASTNode c : astChildren())
// 			list.addAll(c.literals(scopePrefix));
// 		return list;
// 	}

// 	syn ArrayList<lang.ast.Clause> ASTNode.clauses(String scopePrefix) {
// 		// An add-hoc way of implementing parameterized collection attributes
// 		ArrayList<lang.ast.Clause> list = new ArrayList<>();
// 		list.addAll(asClauses(scopePrefix));
// 		for (ASTNode c : astChildren())
// 			list.addAll(c.literals(scopePrefix));
// 		return list;
// 	}
// }
