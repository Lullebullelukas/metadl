import lang.relation.Relation;
import lang.relation.PseudoTuple;
import java.util.ArrayList;
import java.util.HashMap;
import java.lang.reflect.ParameterizedType;
import lang.io.StringUID;

aspect DatalogProject {
	/**
	   Build the name of the relation from the dynamic type of the
	   node.
	 */
	public String ASTNode.getRelation() {
		String nodeName = this.getClass().getName();
		String[] splitNodeName = nodeName.split("\\.");
		String relName = splitNodeName[splitNodeName.length - 1];
		return relName;
	}

	/**
	   Assign a unique ID to every node in the AST
	 */
	public int ASTNode.UID = 0;
	public static int ASTNode.RunningId = 0;
	public synchronized int ASTNode.getNodeId() {
		if (UID == 0) {
			UID = ++ASTNode.RunningId;
		}
		return UID;
	}

	public class TupleWrapper {
		public class RelationTuple {
			String relation;
			PseudoTuple tuple;
			public RelationTuple(String relation, PseudoTuple tuple) {
				this.relation = relation;
				this.tuple = tuple;
			}
		}

		public ArrayList<RelationTuple> tuples = new ArrayList<>();
		public String defaultRel;

		TupleWrapper() {}

		TupleWrapper(String defaultRel) {
			this.defaultRel = defaultRel;
		}

		public void addTuple(PseudoTuple tpl) {
			assert defaultRel != null;
			tuples.add(new RelationTuple(defaultRel, tpl));
		}

		public void addTuple(String relation, PseudoTuple tpl) {
			tuples.add(new RelationTuple(relation, tpl));
		}

		public Iterable<RelationTuple> getTuples() {
			return tuples;
		}
	}

	public class RelationMap {
		public HashMap<String, Relation> nameToRelMap = new HashMap<>();
		public void add(TupleWrapper tplw) {
			for (TupleWrapper.RelationTuple tpl : tplw.getTuples()) {
				Relation r;
				r = nameToRelMap.get(tpl.relation);
				if (r == null) {
					// Create a relation if it does not exist
					r = new Relation(tpl.tuple.arity());
					nameToRelMap.put(tpl.relation, r);
				}
				r.addTuple(tpl.tuple);
			}
		}
	}

	coll Relation Program.datalogProjection() [new Relation(5)] with addTuples;

	syn java.util.List<PseudoTuple> ASTNode.toTuples() {
		String relName = getRelation();
		java.util.List<PseudoTuple> ret = new ArrayList<>();

		// the children in the tree
		int childIndex = 0;
		for (int i = 0; i < getNumChild(); ++i) {
			ASTNode child = getChild(i);

			lang.ast.StringConstant Kind = new lang.ast.StringConstant(relName);
			lang.ast.IntConstant ChildId;
			if (child instanceof Opt) {
				if (child.getNumChild() == 0)
					ChildId = new lang.ast.IntConstant("0");
				else
					ChildId = new lang.ast.IntConstant("" + child.getChild(0).getNodeId());
			} else {
				ChildId = new lang.ast.IntConstant("" + child.getNodeId());
			}
			lang.ast.IntConstant CurrentNodeId = new lang.ast.IntConstant("" + getNodeId());
			lang.ast.IntConstant ChildIdx = new lang.ast.IntConstant("" + childIndex++);
			lang.ast.StringConstant Token = new lang.ast.StringConstant("");
			ret.add(new PseudoTuple(Kind, CurrentNodeId, ChildIdx, ChildId, Token));
		}

		// other tokens attached to the node
		for (String t : tokens()) {
			// For every token, we generate two tuples
			// ("NodeKind", CurrentNodeId, ChildIdx, ChildId, "")
			// ("Token", ChildId, 0, 0, "TokenAsString")
			int tokenUID = StringUID.getInstance().uid(t);
			{
				// Add a tuple to the current node relation
				lang.ast.StringConstant Kind = new lang.ast.StringConstant(relName);
				lang.ast.IntConstant ChildId = new lang.ast.IntConstant("" + tokenUID);
				lang.ast.IntConstant CurrentNodeId = new lang.ast.IntConstant("" + getNodeId());
				lang.ast.IntConstant ChildIdx = new lang.ast.IntConstant("" + childIndex++);
				lang.ast.StringConstant Token = new lang.ast.StringConstant("");
				ret.add(new PseudoTuple(Kind, CurrentNodeId, ChildIdx, ChildId, Token));
			}

			{
				// Add a tuple to Token relation
				lang.ast.StringConstant Kind = new lang.ast.StringConstant("Terminal");
				lang.ast.IntConstant ChildId = new lang.ast.IntConstant("0");
				lang.ast.IntConstant CurrentNodeId = new lang.ast.IntConstant("" + tokenUID);
				lang.ast.IntConstant ChildIdx = new lang.ast.IntConstant("0");
				lang.ast.StringConstant Token = new lang.ast.StringConstant(t);
				ret.add(new PseudoTuple(Kind, CurrentNodeId, ChildIdx, ChildId, Token));
			}
		}

		{
			// record the source location
			// ("SourceInfo, CurrentNodeId, Line, Col, "")
			lang.ast.StringConstant Kind = new lang.ast.StringConstant("SourceInfo");
			lang.ast.IntConstant CurrentNodeId = new lang.ast.IntConstant("" + getNodeId());
			lang.ast.IntConstant Line = new lang.ast.IntConstant("" + getLine(getStart()));
			lang.ast.IntConstant Col = new lang.ast.IntConstant("" + getColumn(getStart()));
			lang.ast.StringConstant Token = new lang.ast.StringConstant("");
			ret.add(new PseudoTuple(Kind, CurrentNodeId, Line, Col, Token));
		}

		return ret;
	}

    eq Opt.toTuples() {
		return Collections.emptyList();
	}

	syn java.util.List<String> ASTNode.tokens() = Collections.emptyList();
	eq IntConstant.tokens() {
		return Collections.singletonList(getNUMERAL());
	}
	eq StringConstant.tokens() {
		return Collections.singletonList(getSTRING());
	}
	eq PredicateRef.tokens() {
		return Collections.singletonList(getPRED_ID());
	}
	eq PredicateSymbol.tokens() {
		return Collections.singletonList(getPRED_ID());
	}
	eq FunctorSymbol.tokens() {
		return Collections.singletonList(getFUNC_ID());
	}

	ASTNode contributes toTuples() to Program.datalogProjection() ;

	// public class ProgRelPart {
	// 	public final String name;
	// 	public final PseudoTuple defaultValue;
	// 	ProgRelPart(String name, Object[] defaultValues) {
	// 		this.name = name;
	// 		lang.ast.Term terms[] = new lang.ast.Term[defaultValues.length];
	// 		for (int i = 0; i < defaultValues.length; ++i) {
	// 			if (defaultValues[i] instanceof String) {
	// 				terms[i] = new lang.ast.StringConstant((String)defaultValues[i]);
	// 			} else if (defaultValues[i] instanceof Term) {
	// 				terms[i] = (lang.ast.Term)defaultValues[i];
	// 			} else {
	// 				terms[i] = new lang.ast.IntConstant("" + (Integer)defaultValues[i]);
	// 			}
	// 		}
	// 		this.defaultValue = new PseudoTuple(terms);
	// 	}
	// 	public int arity() { return defaultValue.arity(); }

	// 	public static ProgRelPart[] getProgramRelationStructure() {
	// 		Object[] triple = new Object[]{0, 0, 0};
	// 		Object[] pairString = new Object[]{0, ""};
	// 		ProgRelPart prs[] = {
	// 			new ProgRelPart("Program", triple),
	// 			new ProgRelPart("Lst", triple),
	// 			new ProgRelPart("Rule", triple),
	// 			new ProgRelPart("Fact", triple),
	// 			new ProgRelPart("Atom", triple),
	// 			new ProgRelPart("PredicateSymbol", pairString),
	// 			new ProgRelPart("IntConstant", new Object[]{0, 0}),
	// 			new ProgRelPart("StringConstant", pairString),
	// 			new ProgRelPart("PredicateRef", pairString),
	// 			new ProgRelPart("Variable", pairString),
	// 			new ProgRelPart("IMPORTLiteral", triple),
	// 			new ProgRelPart("EDBLiteral", triple),
	// 			new ProgRelPart("OUTPUTLiteral", triple),
	// 			new ProgRelPart("NEGLiteral", triple),
	// 			new ProgRelPart("BINDLiteral", triple),
	// 			new ProgRelPart("BinaryExclusiveTermLiteral", new Object[] {0, "", 0, 0}),
	// 			new ProgRelPart("Functor", triple),
	// 			new ProgRelPart("FunctorSymbol", pairString),
	// 			new ProgRelPart("SourceInfo", pairString)};
	// 		return prs;
	// 	}
	// }

	syn Relation Program.asRelation() = datalogProjection();
}
