aspect MatchingEqv {
    public class MatchEqv {
        //smallRoot is root of AST for equivalencePatternDecl and bigRoot is root of AST from the program we want to match against the equiv
        public static Map<ASTNode<ASTNode>, ASTNode<ASTNode>> match(ASTNode<ASTNode> smallRoot, ASTNode<ASTNode> bigRoot) {
            HashMap<ASTNode<ASTNode>, ASTNode<ASTNode>> matchMap = new HashMap<ASTNode<ASTNode>, ASTNode<ASTNode>>();
            //if we have a meta variable then match instantly
            //some shortcuts could probably be taken if we know that numChild differs

            System.out.println("Match is running");
            smallRoot.debugPrint(System.out);
            bigRoot.debugPrint(System.out);
            if (matchHelper(smallRoot, bigRoot, matchMap)) {
               matchMap.put(smallRoot, bigRoot);
               System.out.println(matchMap);
               return matchMap;
            } else {
               return Collections.emptyMap();
            }

        }


        public static boolean matchHelper(ASTNode<ASTNode> smallNode,ASTNode<ASTNode> bigNode, Map<ASTNode<ASTNode>, ASTNode<ASTNode>> matchMap) {
            //below checks equivalence for bigRoot node and smallRoot node,
            //metavars in bigTree ignored for now
            if (!(smallNode.getClass().equals(bigNode.getClass()) || smallNode.isMetaVar() )) {
                //no match
                System.out.println(smallNode.getClass());
                System.out.println(bigNode.getClass());
                return false;
            }  
            // int smallChildren = smallNode.getNumChild();
            int bigChildren = bigNode.getNumChild();

            // System.out.println("big children: " + bigChildren);
            // System.out.println("small childern: " + smallChildren);


            //meta variables have a wrapper making the children amount not be what we want it to. Maybe we can get do a try catch instead
            //to make sure we don't get index out of bounds.
            // if (bigChildren != smallChildren) {
            //     System.out.println("B");
            //     return false;
            // }

            for(int i = 0; i < bigChildren ; i++) {
                if(matchHelper(smallNode.getChild(i), bigNode.getChild(i),matchMap)) {
                    //add it to the map??
                    matchMap.put(smallNode, bigNode);
                } else {
                    return false;
                }
            }
            //if we get passed the above loop then we are in a bigLeaf that is equal to the current smallLeaf. Extra thought needs to be
            //put into what part of the meta vars we want to map. The wrapper or the child? 
            matchMap.put(smallNode, bigNode);
            return true;
        } 
    }
} 