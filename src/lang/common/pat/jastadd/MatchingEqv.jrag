aspect MatchingEqv {
    public class MatchEqv {
        //smallRoot is root of AST for equivalencePatternDecl and bigRoot is root of AST from the program we want to match against the equiv
        public static Map<ASTNode<ASTNode>, ASTNode<ASTNode>> match(ASTNode<ASTNode> smallRoot, ASTNode<ASTNode> bigRoot) {
            HashMap<ASTNode<ASTNode>, ASTNode<ASTNode>> matchMap = new HashMap<ASTNode<ASTNode>, ASTNode<ASTNode>>();
            if (matchHelper(smallRoot, bigRoot, matchMap)) {
                //attaching the root, might not be needed, attatched elsewhere for the matchnode
                //matchMap.put(smallRoot, bigRoot);
                return matchMap;
            } else {
                return Collections.emptyMap();
            }

        }


        public static boolean matchHelper(ASTNode<ASTNode> smallNode,ASTNode<ASTNode> bigNode, Map<ASTNode<ASTNode>, ASTNode<ASTNode>> matchMap) {
            //below checks equivalence for bigRoot node and smallRoot node,
            //metavars in bigTree ignored for now
            if (!(smallNode.getClass().equals(bigNode.getClass()) || smallNode.isMetaVar() )) {
                //no match
                return false;
            }  
            //   int bigChildren = bigNode.getNumChild();

            if(smallNode.isMetaVar()) {
                matchMap.put(smallNode, bigNode);
                return true;
            }
            int smallChildren = smallNode.getNumChild();


            //iterating through the amount of children, maybe a check for amountOfChildren should be done?
            for(int i = 0; i < smallChildren ; i++) {
                if(!matchHelper(smallNode.getChild(i), bigNode.getChild(i),matchMap)) {
                    return false;
                }
            }
            //if we get passed the above loop then we are in a bigNode that is equal to the current smallLeaf.
            return true;
        } 
    }
} 