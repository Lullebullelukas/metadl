import lang.cons.PatternConstraint;
import java.util.TreeSet;
import java.util.HashSet;
import java.util.ArrayList;
import java.util.Collections;
import lang.cons.ObjLangASTNode;
import java.lang.reflect.Method;
import java.lang.ReflectiveOperationException;
import lang.ast.AnalyzeContext;
import lang.io.StringUID;
import java.util.Arrays;
import java.io.PrintStream;
import static lang.ast.Constructors.*;
import org.apache.commons.lang3.mutable.MutableInt;

aspect PatternToDatalog {

	/**
	   Assign a unique ID to every node in the AST
	*/
	private int ASTNode.UID = 0;
	public int ASTNode.getNodeId() {
		return UID;
	}

	public void ASTNode.assignIds() {
		assignIds(new MutableInt(0));
	}

	@Override public boolean ASTNode.equals(Object o) {
		if (o == null)
			return false;
		if (o.getClass() != getClass())
			return false;
		ASTNode other = (ASTNode) o;
		if (!tokens().equals(other.tokens()))
			return false;
		if (getNumChild() != other.getNumChild())
			return false;
		for (int i = 0; i < getNumChild(); ++i) {
			if ((getChild(i) == null) !=
				(other.getChild(i) == null)) {
				return false;
			} else if (getChild(i) != null && !getChild(i).equals(other.getChild(i))) {
				return false;
			}
		}
		return true;
	}

	@Override public int ASTNode.hashCode() {
		int m = 31;
		int h = getClass().hashCode();
		h = h * m + tokens().hashCode();
		for (ASTNode c : astChildren())
			if (c != null)
				h = h * m + c.hashCode();
		return h;
	}

	private void ASTNode.assignIds(MutableInt count) {
		// Assign node IDs using a depth first traversal;
		// this ensures a deterministic order for the nodes
		// inside the AST.
		for (ASTNode c : astChildren()) {
			if (c != null)
				c.assignIds(count);
		}

		UID = count.intValue();
		count.increment();
	}

	/**
	   Attributes that implement the MetaVariableTraits interface
	 */

	public static String ASTNode.GAP = "Gap";
	public static String ASTNode.METAVARIABLE = "MetaVar";

	syn String ASTNode.name() {
		String nodeNameFull = this.getClass().getName();
		String[] splitNodeName = nodeNameFull.split("\\.");
		String nodeName = splitNodeName[splitNodeName.length - 1];
		return nodeName;
	}

	public void ASTNode.debugPrintInternal(int offset, PrintStream ps) {
		for (int i = 0; i < offset; ++i)
			ps.print('_');
		ps.println(name() + " : " + varName());
		for (int i = 0; i < getNumChildNoTransform(); ++i) {
			if (getChildNoTransform(i) != null)
				getChildNoTransform(i).debugPrintInternal(offset + 2, ps);
		}
	}

	public void MetaVariable.debugPrintInternal(int offset, PrintStream ps) {
		for (int i = 0; i < offset; ++i)
			ps.print('_');
		ps.println(name() + ":" + getID());
	}

	public void ASTNode.debugPrint(PrintStream ps) {
		debugPrintInternal(0, ps);
	}

	syn String ASTNode.getRelation() = name();

	syn boolean ASTNode.isGap() {
		return name().startsWith(GAP);
	}

	syn boolean ASTNode.isMetaVar() {
		return name().startsWith(METAVARIABLE) && !name().startsWith("MetaVariable");
	}

	public static boolean ASTNode.isWildcardToken(String s) {
		return s.equals("`_");
	}

	syn boolean MetaVariable.isWildcard() = isWildcardToken(getID());

	syn String ASTNode.varName() = varName("");
	syn String ASTNode.varName(String suffix) {
		if (isMetaVar()) {
			try {
				Method m = this.getClass().getMethod("getVar");
				MetaVariable v = (MetaVariable) m.invoke(this);
				if (!v.isWildcard())
					return v.getID() + suffix;
			} catch (ReflectiveOperationException e) {
				throw new Error(e.toString());
			}
		}
		return "v_" + getNodeId() + suffix;
	}

	syn String ASTNode.indexVarName() {
		return "i_" + getNodeId();
	}

	syn ArrayList<lang.ast.CommonLiteral> ASTNode.asLiterals(AnalyzeContext ctx, lang.ast.CommonVariable root);

	public ArrayList<lang.ast.CommonLiteral> ASTNode.metaVarAsLiterals(AnalyzeContext ctx, lang.ast.CommonVariable root) {
		assert isMetaVar();
		java.util.ArrayList<lang.ast.CommonLiteral> ret = new ArrayList<>();

		assert getRelation().startsWith(ASTNode.METAVARIABLE);
		String relName = getRelation().substring(ASTNode.METAVARIABLE.length());
		String predName = ctx.progRelName;
		String kind = "$" + varName("_kind");

		// constrain the type of node that can be matched
		ret.add(literal(ctx.prefix("SUPERTYPE"), kind, relName));


		for (int i = 0; i < getNumChild(); ++i) {

			ASTNode child = getChild(i);
			if (child == null)
				continue;

			// MetaVariable children hold the metavarible ID and nothing else.
			// They should be ignored here.
			if (child instanceof MetaVariable)
				continue;

			ret.add(literal(predName, kind, "$" + varName(), i, "$" + child.varName(), "_"));
		}

		if (ret.size() == 1) {
			// This metavariable node has no children. Just ensure that is bound to
			// the correct AST node type
			ret.add(literal(predName, kind,  "$" + varName(), "_", "_", "_"));
		}


		if (root != null) {
			// This is an a <: `b :> pattern. In this case, we need to ensure that a == b.
			ret.add(literal(predName, kind, root.treeCopyNoTransform(), "_", "_", "_"));
			ret.add(EQ(new lang.ast.Variable(varName()),
					   root.treeCopyNoTransform()));
		}

		return ret;
	}

	static boolean ASTNode.isMetaVarToken(String token) {
		return java.util.regex.Pattern.matches("`[\\p{Alpha}_][\\p{Alnum}_]*", token);
	}

	/**
	   The asLiterals() equations are isomorphic to toTuples()
	   equations in the DatalogProject aspect. The common parts should be
	   factored out to ensure that the relational
	   representation of a program matches the code generated for a pattern.
	 */
	eq ASTNode.asLiterals(AnalyzeContext ctx, lang.ast.CommonVariable root) {
		ArrayList<lang.ast.CommonLiteral> literals = new ArrayList<>();
		if (isGap())
			return literals;
		if (isMetaVar())
			return metaVarAsLiterals(ctx, root);

		String relName = getRelation();

		java.util.ArrayList<lang.ast.CommonLiteral> ret = new ArrayList<>();

		// the children in the tree
		for (int i = 0; i < getNumChild(); ++i) {
			ASTNode child = getChild(i);
			ret.add(literal(ctx.progRelName, relName, root != null ? root : var(varName()), i, var(child.varName()), "_"));
		}


		int childIndex = getNumChild();
		// other tokens attached to the node
		for (String t : tokens()) {
			// For every token, we generate two tuples
			// ("NodeKind", CurrentNodeId, ChildIdx, ChildId, "")
			// ("Token", ChildId, _, _, "TokenAsString")
			int tokenUID = StringUID.getInstance().uid(t);
			String varName = isMetaVarToken(t) ? t : ("t_" + tokenUID);

			if (!isWildcardToken(t)) {
				// Add a tuple to the current node relation
				ret.add(literal(ctx.progRelName, str(relName), root != null ? root : var(varName()), childIndex, var(varName), "_"));
				// Add a tuple to Token relation
				ret.add(literal(ctx.progRelName, "Terminal", var(varName), "_", "_",
								isMetaVarToken(t) ? "_" : str(t)));
			}
			childIndex++;
		}

		if (childIndex == 0) {
			// This node has no children, but it exists in the tree. Emit that.
			ret.add(literal(ctx.progRelName, str(relName), root != null ? root : var(varName()), "_", "_", "_"));
		}

		return ret;
	}

	ASTNode implements ObjLangASTNode;

	syn ArrayList<PatternConstraint> List.constraints() {
		if (getNumChild() == 0) {
			return new ArrayList<>();
		}

		ArrayList<PatternConstraint> cons = new ArrayList<>();
		ASTNode prevNonGap = null;
		ASTNode prev = null;
		boolean seenGap = false;

		for (int i = 0; i < getNumChild(); ++i) {
			ASTNode c = getChild(i);
			if (!c.isGap()) {
				if (!seenGap) {
					// no gaps seen from the beginning, then the index variable
					// is constrained to be equal to the position in the list
					cons.add(PatternConstraint.eq(c, i));
				} else if (prev == prevNonGap) {
					// seen gaps, but the predecessor is not a gap
					// e.g. P(...,$i:t,$j:u,...) -> constrain $i + 1 == $j
					cons.add(PatternConstraint.next(prev, c));
				} else if (prevNonGap != null) {
					// seen gaps, but the predecessor is a gap
					// e.g. P(...,$i:t,...,$j:u,...)
					// There are two alternatives to chosse from:
					// 1. constrain $j > $i
					// 2. no constraint
					// We choose to implement 2 to allow a pattern like
					// ... :- ..., EQ(x, y), ..., $p(...),... . to cover cases
					// where EQ comes before $p and after $p. If ordering is
					// required, the user can add explicit indices.
					cons.add(PatternConstraint.member(c));
				} else if (prevNonGap == null) {
					// seens only gaps before
					cons.add(PatternConstraint.member(c));
				}

				if (i + 1 == getNumChild()) {
					// this is the rightmost element in a list with gaps
					// e.g. P(...,$i:t) -> constrain $i to be the index of the last element
					cons.add(PatternConstraint.last(c));
				}
			}

			if (!c.isGap()) {
				prevNonGap = c;
			} else {
				seenGap = true;
			}
			prev = c;
		}
		return cons;
	}

	syn ArrayList<lang.ast.Clause> ASTNode.asClauses(AnalyzeContext ctx) = new ArrayList<>();
	eq List.asClauses(AnalyzeContext ctx) {
		// TODO: this is not used currently used, because none of the
		// constraints implements the generateClause method.
		// Remove maybe?
		ArrayList<PatternConstraint> cons = constraints();
		if (cons.isEmpty())
			return new ArrayList<>();
		ArrayList<lang.ast.Clause> clauses = new ArrayList<>();
		for (PatternConstraint c : cons) {
			lang.ast.Clause cls = c.generateClause(ctx);
			if (cls != null)
				clauses.add(cls);
		}
		return clauses;
	}

	eq List.asLiterals(AnalyzeContext ctx, lang.ast.CommonVariable root) {
		ArrayList<lang.ast.CommonLiteral> lits = new ArrayList<>();

		if (getNumChild() == 1 && getChild(0).isGap())
			return lits;

		ArrayList<PatternConstraint> cons = constraints();
		if (cons.isEmpty())
			return super.asLiterals(ctx, null);

		for (PatternConstraint c : cons)
			lits.addAll(c.generateLiterals(ctx));
		return lits;
	}

	eq MetaVariable.asLiterals(AnalyzeContext ctx, lang.ast.CommonVariable root) = new ArrayList<>();
	eq Opt.asLiterals(AnalyzeContext ctx, lang.ast.CommonVariable root) {
		return super.asLiterals(ctx, root);
	}


	syn ArrayList<lang.ast.CommonLiteral> ASTNode.literals(AnalyzeContext ctx, lang.ast.CommonVariable root) {
		// An add-hoc way of implementing parameterized collection attributes
		ArrayList<lang.ast.CommonLiteral> list = new ArrayList<>();
		list.addAll(asLiterals(ctx, root));
		if (isGap())
			return list;
		for (ASTNode c : astChildren()) {
			if (c == null) {
				// Metavariable nodes may have null children, skip them
				assert isMetaVar();
			} else {
				list.addAll(c.literals(ctx, null));
			}
		}
		return list;
	}

	syn TreeSet<lang.ast.Variable> ASTNode.metavariables() {
		TreeSet<lang.ast.Variable> vars = new TreeSet<>(lang.ast.Term.termComparator);
		for (ASTNode c : astChildren()) {
			if (c != null)
				// Gaps might have null children, because the inherit from
				// the original AST node, skip them
				vars.addAll(c.metavariables());
		}
		for (String t : tokens()) {
			// Collect any tokens that are a metavariable
			if (isMetaVarToken(t) && !isWildcardToken(t))
				vars.add(new lang.ast.Variable(t));
		}
		return vars;
	}

	eq MetaVariable.metavariables() {
		TreeSet<lang.ast.Variable> vars = new TreeSet<>(lang.ast.Term.termComparator);
		if (isWildcard()) {
			// This a wildcard, don't add any metavariable for it
			return vars;
		}

		vars.add(new lang.ast.Variable(getID()));
		return vars;
	}
}
