import java.util.TreeSet;
import java.util.HashSet;
import java.util.ArrayList;
import java.util.Collections;
import lang.cons.ObjLangASTNode;
import java.lang.reflect.Method;
import java.lang.ReflectiveOperationException;
import lang.ast.AnalyzeContext;
import lang.ast.Constructors;
import static lang.ast.Constructors.*;
import lang.io.StringUID;
import java.util.Arrays;
import java.io.PrintStream;

aspect AnalyzeBlock {
	public class PatLang {
		/**
		   Build a rule of the shape:
		   $name(n_id, v) :- P($nodeKind, n_id, idx, t_id, _), P("Terminal", t_id, _, _, v).
		   or, if converFunctor != null:
		   $name(n_id, v) :- P($nodeKind, n_id, idx, t_id, _), P("Terminal", t_id, _, _, w), BIND(v, $converFunctor(w)).
		*/
		public static lang.ast.Rule makeIdentifierRule(AnalyzeContext ctx,
													   String nodeKind,
													   String name,
													   int idx,
													   String convertFunctor) {
			lang.ast.List<lang.ast.CommonLiteral> headList = new lang.ast.List<>();
			lang.ast.List<lang.ast.CommonLiteral> bodyList = new  lang.ast.List<>();

			lang.ast.List<lang.ast.Term> headVars = new lang.ast.List<>();
			headVars.add(new lang.ast.Variable("n_id"));
			headVars.add(new lang.ast.Variable("v"));
			lang.ast.CommonLiteral head = new lang.ast.Literal(new lang.ast.PredicateSymbol(ctx.scopePrefix + name),
															headVars);

			// ID(n_id, v) :- P(nodeKind, n_id, idx, t_id, _), P("Terminal", t_id, _, _, v).
			lang.ast.List<lang.ast.Term> body0Vars = new lang.ast.List<lang.ast.Term>()
				.add(new lang.ast.StringConstant(nodeKind))
				.add(new lang.ast.Variable("n_id"))
				.add(new lang.ast.IntConstant("" + idx))
				.add(new lang.ast.Variable("t_id"))
				.add(new lang.ast.Wildcard());

			lang.ast.List<lang.ast.Term> body1Vars = new lang.ast.List<lang.ast.Term>()
				.add(new lang.ast.StringConstant("Terminal"))
				.add(new lang.ast.Variable("t_id"))
				.add(new lang.ast.Wildcard())
				.add(new lang.ast.Wildcard())
				.add(new lang.ast.Variable(convertFunctor != null ? "w" : "v"));

			headList.add(head);
			bodyList.add(new lang.ast.Literal(new lang.ast.PredicateSymbol(ctx.progRelName), body0Vars))
				.add(new lang.ast.Literal(new lang.ast.PredicateSymbol(ctx.progRelName), body1Vars));

			if (convertFunctor != null) {
				// name(n_id, v) :- P(nodeKind, n_id, idx, t_id, _), P("Terminal", t_id, _, _, w), BIND(v, convertFunctor(w))
				bodyList.add(BIND(new lang.ast.Variable("v"),
								  new lang.ast.Functor(new lang.ast.FunctorSymbol(convertFunctor),
													   new lang.ast.List<lang.ast.Expr>()
													   .add(new lang.ast.Variable("w")))));
			}

			return new lang.ast.Rule(headList, bodyList);
		}

		/**
		   Build a rule ID(t_id, s) :- P("Terminal", t_id, _, _, s).
		 */
		public static lang.ast.Rule makeTerminalToIdentifierRule(AnalyzeContext ctx,
																 String name) {
			lang.ast.List<lang.ast.CommonLiteral> headList = new lang.ast.List<>();
			lang.ast.List<lang.ast.CommonLiteral> bodyList = new  lang.ast.List<>();

			lang.ast.List<lang.ast.Term> headVars = new lang.ast.List<>();
			headVars.add(new lang.ast.Variable("t_id"));
			headVars.add(new lang.ast.Variable("v"));
			lang.ast.CommonLiteral head = new lang.ast.Literal(new lang.ast.PredicateSymbol(ctx.scopePrefix + name),
															headVars);

			lang.ast.List<lang.ast.Term> bodyVars = new lang.ast.List<lang.ast.Term>()
				.add(new lang.ast.StringConstant("Terminal"))
				.add(new lang.ast.Variable("t_id"))
				.add(new lang.ast.Wildcard())
				.add(new lang.ast.Wildcard())
				.add(new lang.ast.Variable("v"));

			headList.add(head);
			bodyList.add(new lang.ast.Literal(new lang.ast.PredicateSymbol(ctx.progRelName), bodyVars));

			return new lang.ast.Rule(headList, bodyList);
		}



		public static lang.ast.Rule makeSrcInfoRule(AnalyzeContext ctx) {
			lang.ast.List<lang.ast.CommonLiteral> headList = new lang.ast.List<>();
			lang.ast.List<lang.ast.CommonLiteral> bodyList = new  lang.ast.List<>();

			/* SRC(n, startLine, startCol, endLine, endCol, file) :- P("SrcLocStart", n, startLine, startCol, file),
			   P("SrcLocEnd", n, endLine, endCol, _). */

			return rule(literal(ctx.scopePrefix + "SRC", "$n", "$sl", "$sc", "$el", "$ec", "$f"),
						literal(ctx.srcRelName, "$n", "$sl", "$sc", "$el", "$ec", "$f"));
		}

		public static lang.ast.Rule makeIndexRule(AnalyzeContext ctx) {
			lang.ast.List<lang.ast.CommonLiteral> headList = new lang.ast.List<>();
			lang.ast.List<lang.ast.CommonLiteral> bodyList = new  lang.ast.List<>();

			// The INDEX relation maps a node to its position inside a list
			// INDEX(n, i) :- P("List", _, i, n, _)
			headList.add(new lang.ast.Literal(new lang.ast.PredicateSymbol(ctx.scopePrefix + "INDEX"),
										   new lang.ast.List<lang.ast.Term>()
										   .add(new lang.ast.Variable("n"))
										   .add(new lang.ast.Variable("i"))));
			bodyList.add(new lang.ast.Literal(new lang.ast.PredicateSymbol(ctx.progRelName),
										   new lang.ast.List<lang.ast.Term>()
										   .add(new lang.ast.StringConstant("List"))
										   .add(new lang.ast.Wildcard())
										   .add(new lang.ast.Variable("i"))
										   .add(new lang.ast.Variable("n"))
										   .add(new lang.ast.Wildcard())));
			return new lang.ast.Rule(headList, bodyList);
		}

		public static lang.ast.Rule makeParentRule(AnalyzeContext ctx) {
			lang.ast.List<lang.ast.CommonLiteral> headList = new lang.ast.List<>();
			lang.ast.List<lang.ast.CommonLiteral> bodyList = new  lang.ast.List<>();
			// The PARENT relation maps a node to its children
			// PARENT(n, c) :- P(x, n, _, c, _), NEQ(t, "SrcLocBegin"), NEQ(t, "SrcLocEnd"), NEQ(x, "Terminal"), NEQ(x, "REWRITE"), NEQ(x, "ATTR_type").
			headList.add(new lang.ast.Literal(new lang.ast.PredicateSymbol(ctx.scopePrefix + "PARENT"),
										   new lang.ast.List<lang.ast.Term>()
										   .add(new lang.ast.Variable("n"))
										   .add(new lang.ast.Variable("c"))));
			bodyList.add(new lang.ast.Literal(new lang.ast.PredicateSymbol(ctx.progRelName),
										   new lang.ast.List<lang.ast.Term>()
										   .add(new lang.ast.Variable("t"))
										   .add(new lang.ast.Variable("n"))
										   .add(new lang.ast.Wildcard())
										   .add(new lang.ast.Variable("c"))
										   .add(new lang.ast.Wildcard())));
			bodyList.add(NEQ(new lang.ast.Variable("t"), new lang.ast.StringConstant("SrcLocStart")));
			bodyList.add(NEQ(new lang.ast.Variable("t"), new lang.ast.StringConstant("SrcLocEnd")));
			bodyList.add(NEQ(new lang.ast.Variable("t"), new lang.ast.StringConstant("Terminal")));

			// TODO: The following two relations are Java specific. This method should be parameterized.
			bodyList.add(NEQ(new lang.ast.Variable("t"), new lang.ast.StringConstant("REWRITE")));

			return new lang.ast.Rule(headList, bodyList);
		}

		public static lang.ast.Rule makeExistsRule(AnalyzeContext ctx) {
			lang.ast.List<lang.ast.CommonLiteral> headList = new lang.ast.List<>();
			lang.ast.List<lang.ast.CommonLiteral> bodyList = new  lang.ast.List<>();
			// Predicate to check the existence of a node
			// EXISTS(n) :- P(_, n, _, _, _).
			headList.add(new lang.ast.Literal(new lang.ast.PredicateSymbol(ctx.scopePrefix + "EXISTS"),
										   new lang.ast.List<lang.ast.Term>()
										   .add(new lang.ast.Variable("n"))));
			bodyList.add(new lang.ast.Literal(new lang.ast.PredicateSymbol(ctx.progRelName),
										   new lang.ast.List<lang.ast.Term>()
										   .add(new lang.ast.Wildcard())
										   .add(new lang.ast.Variable("n"))
										   .add(new lang.ast.Wildcard())
										   .add(new lang.ast.Wildcard())
										   .add(new lang.ast.Wildcard())));
			return new lang.ast.Rule(headList, bodyList);
		}

		public static java.util.List<lang.ast.Rule>  makeSuperTypeRelation(AnalyzeContext ctx) {
			java.util.List<lang.ast.Rule> ret = new ArrayList<>();

			// Add facts SUPERTYPE(nodeType, nodeSuperType)
			for (String nodeType : PatternGrammarInfo.getNodeType()) {
				if (nodeType.equals("List") ||
					nodeType.equals("Opt") ||
					nodeType.equals("ASTNode"))
					continue;

				// SUPERTYPE is reflexive
				// SUPERTYPE(nodeType, nodeType) :- EQ(0, 0).
				ret.add(rule(literal(ctx.scopePrefix + "SUPERTYPE", nodeType, nodeType),
							 EQ(new lang.ast.IntConstant("0"), new lang.ast.IntConstant("0"))));

				String nodeSuperType = PatternGrammarInfo.getNodeSuperType(nodeType);
				if (nodeSuperType == null || nodeSuperType.equals("ASTNode"))
					continue;

				// SUPERTYPE(nodeType, nodeSuperType) :- EQ(0, 0).
				ret.add(rule(literal(ctx.scopePrefix + "SUPERTYPE", nodeType, nodeSuperType),
							 EQ(new lang.ast.IntConstant("0"), new lang.ast.IntConstant("0"))));
			}

			// Rule to compute the transitive closure of SUPERTYPE
			ret.add(rule(literal(ctx.prefix("SUPERTYPE"), "$t", "$s"),
						 literal(ctx.prefix("SUPERTYPE"), "$t", "$s1"),
						 literal(ctx.prefix("SUPERTYPE"), "$s1", "$s")));

			return ret;
		}

		public static lang.ast.Rule makeProvenanceRule(AnalyzeContext ctx) {
			return rule(literal(ctx.scopePrefix + "PROVENANCE", "$x", "$y", "$z"),
						literal(ctx.provenanceRelName, "$x", "$y", "$z"));
		}
	}
}
