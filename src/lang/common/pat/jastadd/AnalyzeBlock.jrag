import lang.cons.Constraint;
import java.util.TreeSet;
import java.util.HashSet;
import java.util.ArrayList;
import java.util.Collections;
import lang.cons.ObjLangASTNode;
import java.lang.reflect.Method;
import java.lang.ReflectiveOperationException;
import lang.ast.AnalyzeContext;
import lang.io.StringUID;
import java.util.Arrays;
import java.io.PrintStream;

aspect AnalyzeBlock {
	public class PatLang {
		public static lang.ast.Atom atom(String pred, Object ...args) {
			lang.ast.List<lang.ast.Term> terms = new lang.ast.List<>();
			for (Object o : args) {
				if (o instanceof Integer) {
					terms.add(new lang.ast.IntConstant("" + o));
				} else if (o instanceof String) {
					String s = (String) o;
					if (s.startsWith("$"))
						terms.add(new lang.ast.Variable(s.substring(1)));
					else if (s.equals("_"))
						terms.add(new lang.ast.Wildcard());
					else
						terms.add(new lang.ast.StringConstant(s));
				} else {
					throw new RuntimeException("Can't interpret argument.");
				}
			}
			return new lang.ast.Atom(new lang.ast.PredicateSymbol(pred), terms);
		}

		public static lang.ast.Rule rule(lang.ast.CommonLiteral ...literals) {
			lang.ast.List<lang.ast.CommonLiteral> headList = new lang.ast.List<>();
			headList.add(literals[0]);

			lang.ast.List<lang.ast.CommonLiteral> bodyList = new lang.ast.List<>();
			for (int i = 1; i < literals.length; ++i)
				bodyList.add(literals[i]);

			lang.ast.Rule r = new lang.ast.Rule(headList, bodyList);

			return r;
		}

		public static lang.ast.Literal NEQ(lang.ast.Term t1, lang.ast.Term t2) {
			return new lang.ast.NEQLiteral(new lang.ast.PredicateSymbol("NEQ"), t1, t2);
		}

		public static lang.ast.Literal EQ(lang.ast.Term t1, lang.ast.Term t2) {
			return new lang.ast.EQLiteral(new lang.ast.PredicateSymbol("EQ"), t1, t2);
		}

		public static lang.ast.Literal NOT(lang.ast.CommonLiteral l) {
			return new lang.ast.NEGLiteral(new lang.ast.PredicateSymbol("NEG"), l);
		}

		public static lang.ast.Rule implicitTypeDecl(AnalyzeContext ctx) {
			lang.ast.List<lang.ast.CommonLiteral> head = new lang.ast.List<>();
			lang.ast.List<lang.ast.CommonLiteral> body = new lang.ast.List<>();
			lang.ast.List<lang.ast.Term> vars = new lang.ast.List<>();
			vars.add(new lang.ast.StringConstant("")).add(new lang.ast.IntConstant("0")).add(new lang.ast.IntConstant("0"))
				.add(new lang.ast.IntConstant("0")).add(new lang.ast.StringConstant("0"));

			head.add(new lang.ast.Atom(new lang.ast.PredicateSymbol(ctx.progRelName), vars));
			body.add(new lang.ast.NEQLiteral(new lang.ast.PredicateSymbol("NEQ"),
											 new lang.ast.IntConstant("0"),
											 new lang.ast.IntConstant("0")));

			return new lang.ast.Rule(head, body);
		}

		/**
		   Build a rule of the shape:
		   $name(n_id, v) :- P($nodeKind, n_id, $idx, c_id, _), $name(c_id, v).
		 */
		public static lang.ast.Rule associateIdentifierToParentNode(AnalyzeContext ctx,
																	String nodeKind,
																	String name,
																	int idx) {
			lang.ast.List<lang.ast.CommonLiteral> headList = new lang.ast.List<>();
			lang.ast.List<lang.ast.CommonLiteral> bodyList = new  lang.ast.List<>();

			lang.ast.List<lang.ast.Term> headVars = new lang.ast.List<>();
			headVars.add(new lang.ast.Variable("n_id"));
			headVars.add(new lang.ast.Variable("v"));
			headList.add(new lang.ast.Atom(new lang.ast.PredicateSymbol(ctx.scopePrefix + name),
										   headVars));

			// ID(n_id, v) :- P(nodeKind, n_id, idx, c_id, _), ID(c_id, v).
			lang.ast.List<lang.ast.Term> body0Vars = new lang.ast.List<lang.ast.Term>()
				.add(new lang.ast.StringConstant(nodeKind))
				.add(new lang.ast.Variable("n_id"))
				.add(new lang.ast.IntConstant("" + idx))
				.add(new lang.ast.Variable("c_id"))
				.add(new lang.ast.Wildcard());

			lang.ast.List<lang.ast.Term> body1Vars = new lang.ast.List<lang.ast.Term>()
				.add(new lang.ast.Variable("c_id"))
				.add(new lang.ast.Variable("v"));


			bodyList.add(new lang.ast.Atom(new lang.ast.PredicateSymbol(ctx.progRelName), body0Vars))
				.add(new lang.ast.Atom(new lang.ast.PredicateSymbol(ctx.scopePrefix + name), body1Vars));


			return new lang.ast.Rule(headList, bodyList);
		}

		/**
		   Build a rule of the shape:
		   $name(n_id, v) :- P($nodeKind, n_id, idx, t_id, _), P("Terminal", t_id, _, _, v).
		   or, if converFunctor != null:
		   $name(n_id, v) :- P($nodeKind, n_id, idx, t_id, _), P("Terminal", t_id, _, _, w), BIND(v, $converFunctor(w)).
		*/
		public static lang.ast.Rule makeIdentifierRule(AnalyzeContext ctx,
													   String nodeKind,
													   String name,
													   int idx,
													   String convertFunctor) {
			lang.ast.List<lang.ast.CommonLiteral> headList = new lang.ast.List<>();
			lang.ast.List<lang.ast.CommonLiteral> bodyList = new  lang.ast.List<>();

			lang.ast.List<lang.ast.Term> headVars = new lang.ast.List<>();
			headVars.add(new lang.ast.Variable("n_id"));
			headVars.add(new lang.ast.Variable("v"));
			lang.ast.CommonLiteral head = new lang.ast.Atom(new lang.ast.PredicateSymbol(ctx.scopePrefix + name),
															headVars);

			// ID(n_id, v) :- P(nodeKind, n_id, idx, t_id, _), P("Terminal", t_id, _, _, v).
			lang.ast.List<lang.ast.Term> body0Vars = new lang.ast.List<lang.ast.Term>()
				.add(new lang.ast.StringConstant(nodeKind))
				.add(new lang.ast.Variable("n_id"))
				.add(new lang.ast.IntConstant("" + idx))
				.add(new lang.ast.Variable("t_id"))
				.add(new lang.ast.Wildcard());

			lang.ast.List<lang.ast.Term> body1Vars = new lang.ast.List<lang.ast.Term>()
				.add(new lang.ast.StringConstant("Terminal"))
				.add(new lang.ast.Variable("t_id"))
				.add(new lang.ast.Wildcard())
				.add(new lang.ast.Wildcard())
				.add(new lang.ast.Variable(convertFunctor != null ? "w" : "v"));

			headList.add(head);
			bodyList.add(new lang.ast.Atom(new lang.ast.PredicateSymbol(ctx.progRelName), body0Vars))
				.add(new lang.ast.Atom(new lang.ast.PredicateSymbol(ctx.progRelName), body1Vars));

			if (convertFunctor != null) {
				// name(n_id, v) :- P(nodeKind, n_id, idx, t_id, _), P("Terminal", t_id, _, _, w), BIND(v, convertFunctor(w))
				bodyList.add(new lang.ast.BINDLiteral(new lang.ast.PredicateSymbol("BIND"),
													  new lang.ast.Variable("v"),
													  new lang.ast.Functor(new lang.ast.FunctorSymbol(convertFunctor),
																		   new lang.ast.List<lang.ast.Expr>()
																		   .add(new lang.ast.Variable("w")))));
			}

			return new lang.ast.Rule(headList, bodyList);
		}

		/**
		   Build a rule ID(t_id, s) :- P("Terminal", t_id, _, _, s).
		 */
		public static lang.ast.Rule makeTerminalToIdentifierRule(AnalyzeContext ctx,
																 String name) {
			lang.ast.List<lang.ast.CommonLiteral> headList = new lang.ast.List<>();
			lang.ast.List<lang.ast.CommonLiteral> bodyList = new  lang.ast.List<>();

			lang.ast.List<lang.ast.Term> headVars = new lang.ast.List<>();
			headVars.add(new lang.ast.Variable("t_id"));
			headVars.add(new lang.ast.Variable("v"));
			lang.ast.CommonLiteral head = new lang.ast.Atom(new lang.ast.PredicateSymbol(ctx.scopePrefix + name),
															headVars);

			lang.ast.List<lang.ast.Term> bodyVars = new lang.ast.List<lang.ast.Term>()
				.add(new lang.ast.StringConstant("Terminal"))
				.add(new lang.ast.Variable("t_id"))
				.add(new lang.ast.Wildcard())
				.add(new lang.ast.Wildcard())
				.add(new lang.ast.Variable("v"));

			headList.add(head);
			bodyList.add(new lang.ast.Atom(new lang.ast.PredicateSymbol(ctx.progRelName), bodyVars));

			return new lang.ast.Rule(headList, bodyList);
		}



		public static lang.ast.Rule makeSrcInfoRule(AnalyzeContext ctx) {
			lang.ast.List<lang.ast.CommonLiteral> headList = new lang.ast.List<>();
			lang.ast.List<lang.ast.CommonLiteral> bodyList = new  lang.ast.List<>();

			/* SRC(n, startLine, startCol, endLine, endCol, file) :- P("SrcLocStart", n, startLine, startCol, file),
			   P("SrcLocEnd", n, endLine, endCol, _). */

			headList.add(new lang.ast.Atom(new lang.ast.PredicateSymbol(ctx.scopePrefix + "SRC"),
										   new lang.ast.List<lang.ast.Term>()
										   .add(new lang.ast.Variable("n"))
										   .add(new lang.ast.Variable("sl"))
										   .add(new lang.ast.Variable("sc"))
										   .add(new lang.ast.Variable("el"))
										   .add(new lang.ast.Variable("ec"))
										   .add(new lang.ast.Variable("f"))
										   ));
			bodyList.add(new lang.ast.Atom(new lang.ast.PredicateSymbol(ctx.progRelName),
										   new lang.ast.List<lang.ast.Term>()
										   .add(new lang.ast.StringConstant("SrcLocStart"))
										   .add(new lang.ast.Variable("n"))
										   .add(new lang.ast.Variable("sl"))
										   .add(new lang.ast.Variable("sc"))
										   .add(new lang.ast.Variable("f"))));
			bodyList.add(new lang.ast.Atom(new lang.ast.PredicateSymbol(ctx.progRelName),
										   new lang.ast.List<lang.ast.Term>()
										   .add(new lang.ast.StringConstant("SrcLocEnd"))
										   .add(new lang.ast.Variable("n"))
										   .add(new lang.ast.Variable("el"))
										   .add(new lang.ast.Variable("ec"))
										   .add(new lang.ast.Wildcard())));
			return new lang.ast.Rule(headList, bodyList);
		}

		public static lang.ast.Rule makeIndexRule(AnalyzeContext ctx) {
			lang.ast.List<lang.ast.CommonLiteral> headList = new lang.ast.List<>();
			lang.ast.List<lang.ast.CommonLiteral> bodyList = new  lang.ast.List<>();

			// The INDEX relation maps a node to its position inside a list
			// INDEX(n, i) :- P("List", _, i, n, _)
			headList.add(new lang.ast.Atom(new lang.ast.PredicateSymbol(ctx.scopePrefix + "INDEX"),
										   new lang.ast.List<lang.ast.Term>()
										   .add(new lang.ast.Variable("n"))
										   .add(new lang.ast.Variable("i"))));
			bodyList.add(new lang.ast.Atom(new lang.ast.PredicateSymbol(ctx.progRelName),
										   new lang.ast.List<lang.ast.Term>()
										   .add(new lang.ast.StringConstant("List"))
										   .add(new lang.ast.Wildcard())
										   .add(new lang.ast.Variable("i"))
										   .add(new lang.ast.Variable("n"))
										   .add(new lang.ast.Wildcard())));
			return new lang.ast.Rule(headList, bodyList);
		}

		public static lang.ast.Rule makeParentRule(AnalyzeContext ctx) {
			lang.ast.List<lang.ast.CommonLiteral> headList = new lang.ast.List<>();
			lang.ast.List<lang.ast.CommonLiteral> bodyList = new  lang.ast.List<>();
			// The PARENT relation maps a node to its children
			// PARENT(n, c) :- P(x, n, _, c, _), NEQ(t, "SrcLocBegin"), NEQ(t, "SrcLocEnd"), NEQ(x, "Terminal"), NEQ(x, "REWRITE"), NEQ(x, "ATTR_type").
			headList.add(new lang.ast.Atom(new lang.ast.PredicateSymbol(ctx.scopePrefix + "PARENT"),
										   new lang.ast.List<lang.ast.Term>()
										   .add(new lang.ast.Variable("n"))
										   .add(new lang.ast.Variable("c"))));
			bodyList.add(new lang.ast.Atom(new lang.ast.PredicateSymbol(ctx.progRelName),
										   new lang.ast.List<lang.ast.Term>()
										   .add(new lang.ast.Variable("t"))
										   .add(new lang.ast.Variable("n"))
										   .add(new lang.ast.Wildcard())
										   .add(new lang.ast.Variable("c"))
										   .add(new lang.ast.Wildcard())));
			bodyList.add(NEQ(new lang.ast.Variable("t"), new lang.ast.StringConstant("SrcLocStart")));
			bodyList.add(NEQ(new lang.ast.Variable("t"), new lang.ast.StringConstant("SrcLocEnd")));
			bodyList.add(NEQ(new lang.ast.Variable("t"), new lang.ast.StringConstant("Terminal")));

			// TODO: The following two relations are Java 5 specific. This method should be parameterized.
			bodyList.add(NEQ(new lang.ast.Variable("t"), new lang.ast.StringConstant("ATTR_type")));
			bodyList.add(NEQ(new lang.ast.Variable("t"), new lang.ast.StringConstant("ATTR_decl")));
			bodyList.add(NEQ(new lang.ast.Variable("t"), new lang.ast.StringConstant("REWRITE")));

			return new lang.ast.Rule(headList, bodyList);
		}

		public static lang.ast.Rule makeExistsRule(AnalyzeContext ctx) {
			lang.ast.List<lang.ast.CommonLiteral> headList = new lang.ast.List<>();
			lang.ast.List<lang.ast.CommonLiteral> bodyList = new  lang.ast.List<>();
			// Predicate to check the existence of a node
			// EXISTS(n) :- P(_, n, _, _, _).
			headList.add(new lang.ast.Atom(new lang.ast.PredicateSymbol(ctx.scopePrefix + "EXISTS"),
										   new lang.ast.List<lang.ast.Term>()
										   .add(new lang.ast.Variable("n"))));
			bodyList.add(new lang.ast.Atom(new lang.ast.PredicateSymbol(ctx.progRelName),
										   new lang.ast.List<lang.ast.Term>()
										   .add(new lang.ast.Wildcard())
										   .add(new lang.ast.Variable("n"))
										   .add(new lang.ast.Wildcard())
										   .add(new lang.ast.Wildcard())
										   .add(new lang.ast.Wildcard())));
			return new lang.ast.Rule(headList, bodyList);
		}

		public static void makeMetaVariableRelation(AnalyzeContext ctx,
													String nodeKind,
													java.util.List<lang.ast.Rule> ret) {
			// no metavariables for List and Opt
			if (nodeKind.equals("List") ||
				nodeKind.equals("Opt") ||
				nodeKind.equals("ASTNode"))
				return;

			// METAVAR($nodeKind, node_id, child_idx, child_id, aux) :- P($nodeKind, node_id, child_idx, child_id, aux)
			ret.add(new lang.ast.Rule(
							 new lang.ast.List<lang.ast.CommonLiteral>().add(new lang.ast.Atom(new lang.ast.PredicateSymbol(ctx.scopePrefix + "METAVAR"),
																		new lang.ast.List<lang.ast.Term>()
																		.add(new lang.ast.StringConstant(nodeKind))
																		.add(new lang.ast.Variable("node_id"))
																		.add(new lang.ast.Variable("child_idx"))
																		.add(new lang.ast.Variable("child_id"))
																		.add(new lang.ast.Variable("aux")))),
							 new lang.ast.List<lang.ast.CommonLiteral>().add(new lang.ast.Atom(new lang.ast.PredicateSymbol(ctx.progRelName),
																		 new lang.ast.List<lang.ast.Term>()
																		 .add(new lang.ast.StringConstant(nodeKind))
																		 .add(new lang.ast.Variable("node_id"))
																		 .add(new lang.ast.Variable("child_idx"))
																		 .add(new lang.ast.Variable("child_id"))
																		 .add(new lang.ast.Variable("aux"))))));

			// METAVAR(supertype($nodeKind), node_id, child_idx, child_id, aux) :- METAVAR($nodeKind, node_id, child_idx, child_id, aux)
			String nodeSuperType = PatternGrammarInfo.getNodeSuperType(nodeKind);
			if (nodeSuperType != null && !nodeSuperType.equals("ASTNode")) {
				ret.add(new lang.ast.Rule(
								 new lang.ast.List<lang.ast.CommonLiteral>().add(new lang.ast.Atom(new lang.ast.PredicateSymbol(ctx.scopePrefix + "METAVAR"),
																			 new lang.ast.List<lang.ast.Term>()
																			 .add(new lang.ast.StringConstant(nodeSuperType))
																			 .add(new lang.ast.Variable("node_id"))
																			 .add(new lang.ast.Variable("child_idx"))
																			 .add(new lang.ast.Variable("child_id"))
																			 .add(new lang.ast.Variable("aux")))),
								 new lang.ast.List<lang.ast.CommonLiteral>().add(new lang.ast.Atom(new lang.ast.PredicateSymbol(ctx.scopePrefix + "METAVAR"),
																			 new lang.ast.List<lang.ast.Term>()
																			 .add(new lang.ast.StringConstant(nodeKind))
																			 .add(new lang.ast.Variable("node_id"))
																			 .add(new lang.ast.Variable("child_idx"))
																			 .add(new lang.ast.Variable("child_id"))
																			 .add(new lang.ast.Variable("aux"))))));
			}
		}

		public static java.util.List<lang.ast.Rule> makeMetaVariableRelations(AnalyzeContext ctx) {
			java.util.List<lang.ast.Rule> ret = new java.util.ArrayList<>();
			for (String nodeType : PatternGrammarInfo.getNodeType()) {
				makeMetaVariableRelation(ctx, nodeType, ret);
			}
			return ret;
		}
	}
}
