ExprStmt explicit_constructor_invocation =
    type_arguments.a THIS LPAREN argument_list.l? RPAREN SEMICOLON
    {:  return new ExprStmt(new ParConstructorAccess(new IdWrapper("this"), l, a));  :}
  | type_arguments.a SUPER LPAREN argument_list.l? RPAREN SEMICOLON
    {:  return new ExprStmt(new ParSuperConstructorAccess(new IdWrapper("super"), l, a));  :}
  | primary.p DOT type_arguments.a SUPER LPAREN argument_list.l? RPAREN SEMICOLON
    {:  return new ExprStmt(p.qualifiesAccess(new ParSuperConstructorAccess(new IdWrapper("super"), l, a))); :}
  | name.n DOT type_arguments.a SUPER LPAREN argument_list.l? RPAREN SEMICOLON
    {:  return new ExprStmt(n.qualifiesAccess(new ParSuperConstructorAccess(new IdWrapper("super"), l, a))); :}
  ;

Access method_invocation =
    primary.p DOT type_arguments.a IDENTIFIER LPAREN argument_list.l? RPAREN
    {: return p.qualifiesAccess(new ParMethodAccess(new IdWrapper(IDENTIFIER), l, a));  :}
  | name.n DOT type_arguments.a IDENTIFIER LPAREN argument_list.l? RPAREN
    {: return n.qualifiesAccess(new ParMethodAccess(new IdWrapper(IDENTIFIER), l, a));  :}
  | SUPER DOT type_arguments.a IDENTIFIER LPAREN argument_list.l? RPAREN
    {: return new SuperAccess().qualifiesAccess(
                        new ParMethodAccess(new IdWrapper(IDENTIFIER), l, a));  :}
  | name.n DOT.d1 SUPER DOT.d2 type_arguments.a IDENTIFIER LPAREN argument_list.l? RPAREN
    {: return n.qualifiesAccess(new SuperAccess()).qualifiesAccess(
                            new ParMethodAccess(new IdWrapper(IDENTIFIER), l, a));  :}
  ;

MethodDecl method_header =
    modifiers.m? LT type_parameter_list_1.l type.t IDENTIFIER LPAREN formal_parameter_list.p? RPAREN dims.d? throws.tl?
    {: return new GenericMethodDecl(new Modifiers(m), t.addArrayDims(d), new IdWrapper(IDENTIFIER), p, tl, new Opt(), l); :}
  | modifiers.m? LT type_parameter_list_1.l VOID IDENTIFIER LPAREN formal_parameter_list.p? RPAREN throws.tl?
    {: return new GenericMethodDecl(new Modifiers(m), new PrimitiveTypeAccess("void"), new IdWrapper(IDENTIFIER), p, tl, new Opt(), l); :}
  ;

ConstructorDecl constructor_declaration =
    modifiers.m? LT type_parameter_list_1.l IDENTIFIER LPAREN formal_parameter_list.pl? RPAREN throws.tl?
    LBRACE explicit_constructor_invocation.c? block_statements.bl? RBRACE
    {: return new GenericConstructorDecl(new Modifiers(m), new IdWrapper(IDENTIFIER), pl, tl, c, new Block(bl), l); :}
  ;
