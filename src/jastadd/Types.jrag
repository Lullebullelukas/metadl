import lang.ast.Term;
import lang.ast.StringConstant;
import java.util.Comparator;
import java.util.Collections;

aspect Type {
	public abstract class Type {
		public abstract String name();
		public Type join(Type t) {
			// Use a flat type lattice.
			if (this == t) {
				return this;
			} else if (this == BadType.get() || t == BadType.get()) {
				return BadType.get();
			} else if (this == UnknownType.get()) {
				return t;
			} else if (t == UnknownType.get()) {
				return this;
			} else {
				return BadType.get();
			}
		}
	}

	public class IntegerType extends Type {
		private static IntegerType intI = new IntegerType();
		private IntegerType() { super(); }
		@Override public String name() {
			return "Integer";
		}
		public static IntegerType get() { return intI; }

	}

	public class StringType extends Type {
		private static StringType strI = new StringType();
		private StringType() { super(); }
		@Override public String name() {
			return "String";
		}
		public static StringType get() {
			return strI;
		}
	}

	public class PredicateRefType extends Type {
		private static PredicateRefType predI = new PredicateRefType();
		private PredicateRefType() { super(); }
		@Override public String name() {
			return "PredicateRef";
		}
		public static PredicateRefType get() {
			return predI;
		}
	}

	public class UnknownType extends Type {
		private static UnknownType unknownI = new UnknownType();
		private UnknownType() { super(); }
		@Override public String name() {
			return "Unknown";
		}
		public static UnknownType get() {
			return unknownI;
		}
	}

	public class BadType extends Type {
		private static  BadType badI = new BadType();
		private BadType() { super(); }
		@Override public String name() {
			return "Bad";
		}
		public static BadType get() {
			return badI;
		}
	}

	public class PredicateType {
		private ArrayList<Type> types;
		public PredicateType(int arity) {
			types = new ArrayList<>();
			for (int i = 0; i < arity; ++i)
				types.add(UnknownType.get());
		}

		@Override public String toString() {
			StringBuilder sb = new StringBuilder();
			sb.append("(");
			boolean first = true;
			for (Type t : types) {
				if (first) {
					first = false;
				} else {
					sb.append(", ");
				}
				sb.append(t.name());
			}
			sb.append(")");
			return sb.toString();
		}

		public void joinAt(int i, Type t) {
			types.set(i, types.get(i).join(t));
		}

		public Type get(int i) {
			return types.get(i);
		}

		public int arity() {
			return types.size();
		}

		public static class Index {
			private int i;
			private Type t;
			public Index(int i, Type t) {
				this.i = i;
				this.t = t;
			}
		}

		public void join(Index t) {
			joinAt(t.i, t.t);
		}
	}

	public class TypeName {
		public static String string() { return "__String__"; };
		public static String integer() { return "__Integer__"; };
		public static String predref() { return "__PredicateRef__"; };

		public static StringConstant stringT() { return new StringConstant(string()); };
		public static StringConstant integerT() { return new StringConstant(integer()); };
		public static StringConstant predRefT() { return new StringConstant(predref()); };
		public static StringConstant unknownT() { return new StringConstant("__Unknown__"); };
		public static StringConstant typeT() { return new StringConstant("__Type__"); };
		public static StringConstant varT() { return new StringConstant("__Var__"); };
		public static StringConstant badT() { return new StringConstant("__Bad__"); };
	}

	public class TypeComparator implements Comparator<Term> {
		public int compare(Term t1, Term t2) {
			return t1.type().toString().compareTo(t2.type().toString());
		}

		private static TypeComparator instance = null;
		public static TypeComparator get() {
			if (instance == null) {
				instance = new TypeComparator();
			}
			return instance;
		}
	}
}

aspect TypeCheck {
	public class TypeError implements Comparable<TypeError> {
		private FormalPredicate pred;
		private ArrayList<Integer> pos;
		public void addUndefined(int i) {
			pos.add(i + 1);
		}
		public void addContradictory(int i) {
			pos.add(-i - 1);
		}
		public TypeError(FormalPredicate pred) {
			this.pred = pred;
		}
		@Override public int compareTo(TypeError other) {
			if (pred.equals(other.pred))
				return 0;
			return FormalPredicate.formalPredicateComparator
				.compare(pred, other.pred);
		}
		public String report() {
			StringBuffer sb = new StringBuffer();
			sb.append("Predicate " + pred.getPRED_ID() + " is not well-typed: ");
			for (int i = 0; i < pos.size(); ++i) {
				int e = pos.get(i);
				if (e >= 0)
					sb.append("undefined type at position " + (e - 1));
				else
					sb.append("contradictory type at position " + (e + 1));
				if (i < pos.size() - 1)
					sb.append(", ");
				else
					sb.append(".");
			}
			return sb.toString();
		}
	}

	// Type errors for the program. Empty iff the program
	// is well-typed.
	coll TreeSet<TypeError> Program.typeErrors() [new TreeSet<>()];

	syn TypeError FormalPredicate.typeError() {
		TypeError err = null;
		for (int i = 0; i < type().arity(); ++i) {
			if (type().get(i) == BadType.get()) {
				if (err == null)
					err = new TypeError(this);
				err.addContradictory(i);
			} else if (type().get(i) == UnknownType.get()) {
				if (err == null)
					err = new TypeError(this);
				err.addUndefined(i);
			}
		}
		return err;
	}

	FormalPredicate contributes typeError() when (typeError() != null) to Program.typeErrors();
}

aspect TypeInference {
	coll PredicateType FormalPredicate.initialType() [new PredicateType(realArity())] with join root Program;
	inh int Expr.indexInLiteral();
	eq Atom.getTerms(int i).indexInLiteral() {
		return i;
	}
	eq Literal.getChild().indexInLiteral() = -1;
	eq Expr.getChild().indexInLiteral() = -1;
	eq AnalyzeBlock.getProgramRef().indexInLiteral() = -1;
	// explicit rules for special literals
	eq EDBLiteral.getPredicateRef().indexInLiteral() = 0;
	eq EDBLiteral.getFileLoc().indexInLiteral() = 1;
	eq OUTPUTLiteral.getTerm().indexInLiteral() = 0;
	eq IMPORTLiteral.getFileLoc().indexInLiteral() = 0;
	eq IMPORTLiteral.getProgramRef().indexInLiteral() = 1;


	IntConstant contributes (new PredicateType.Index(indexInLiteral(), IntegerType.get()))
		when indexInLiteral() >= 0
		to FormalPredicate.initialType()
		for literal().getPredicate().formalpredicate();

	StringConstant contributes (new PredicateType.Index(indexInLiteral(), StringType.get()))
		when indexInLiteral() >= 0
		to FormalPredicate.initialType()
		for literal().getPredicate().formalpredicate();

	PredicateRef contributes (new PredicateType.Index(indexInLiteral(), PredicateRefType.get()))
		when indexInLiteral() >= 0
		to FormalPredicate.initialType()
		for literal().getPredicate().formalpredicate();

	// map variable names to formal predicates and position of the respective
	// variable in a given predicate
	coll VariableMap Clause.varMap() [new VariableMap()] with add;

	Variable contributes this
		when indexInLiteral() >= 0
		to Clause.varMap()
		for literal().clause();

	AnalyzeBlock contributes nta getAllClauses() to Clause.varMap();
	AnalyzeBlock contributes nta getAllClauses() to FormalPredicate.initialType();
	Pattern contributes nta getLiterals() to Clause.varMap();

	public class VariableMap {
		private Map<String, java.util.List<Variable>> m = new HashMap<>();
		public void add(Variable v) {
			java.util.List<Variable> occurences = m.get(v.getVAR_ID());
			if (occurences == null) {
				occurences = new ArrayList<>();
				m.put(v.getVAR_ID(), occurences);
			}
			occurences.add(v);
		}

		public java.util.List<Variable> get(String varName) {
			java.util.List<Variable> entry = m.get(varName);
			if (entry == null) {
				return Collections.emptyList();
			}
			return entry;
		}
	}

	syn PredicateType FormalPredicate.type() circular [initialType()];
	eq FormalPredicate.type() {
		PredicateType current = type();
		for (PredicateSymbol ps : predicates()) {
			if (!(ps.literal() instanceof Atom))
				continue;
			Atom a = (Atom)(ps.literal());
			Clause c = a.clause();

			for (int i = 0; i < a.arity(); ++i) {
				Term t = a.getTerms(i);
				if (!(t instanceof Variable))
					continue;
				String varName = ((Variable) t).getVAR_ID();

				java.util.List<Variable> sources = c.varMap().get(varName);
				for (Variable v : sources) {
					current.joinAt(i, v.vtype());
				}
			}
		}
		return current;
	}

	inh Type Expr.itype();
	eq Literal.getChild().itype() = UnknownType.get();
    eq Functor.getArg(int i).itype() {
		switch (getFunc().getFUNC_ID()) {
		case "add":
		case "mul":
		case "sub":
		case "div":
			return IntegerType.get();
		case "cat":
			return StringType.get();
		default:
			return UnknownType.get();
		}
	}

	eq LTLiteral.getChild().itype() {
		return IntegerType.get();
	}

	eq GTLiteral.getChild().itype() {
		return IntegerType.get();
	}

	eq LTELiteral.getChild().itype() {
		return IntegerType.get();
	}

	eq GTELiteral.getChild().itype() {
		return IntegerType.get();
	}

	inh Expr Expr.sibling();
	eq Literal.getChild().sibling() = null;
	eq BinaryExclusiveTermLiteral.getLeft().sibling() = getRight();
	eq BinaryExclusiveTermLiteral.getRight().sibling() = getLeft();
	eq BINDLiteral.getVariable().sibling() = getRight();
	eq BINDLiteral.getRight().sibling() = getVariable();

	inh Atom Expr.atom();
	eq Literal.getChild().atom() = null;
	eq Atom.getTerms(int i).atom() = this;

	syn Type Expr.vtype() circular [itype()];

	eq Expr.vtype() {
		Type t = vtype();

		if (sibling() != null) {
			t = t.join(sibling().vtype());
		}

		if (atom() != null) {
			Literal l = atom();
			int i = indexInLiteral();
			t = t.join(l.getPredicate().formalpredicate().type().get(i));
		}

		return t;
	}

	eq Functor.vtype() {
		Type t = super.vtype();
		switch (getFunc().getFUNC_ID()) {
		case "add":
		case "mul":
		case "sub":
		case "div":
			t = t.join(IntegerType.get());
		case "cat":
			t = t.join(StringType.get());
		default:
			t = t.join(BadType.get());
		}
		return t;
	}

	eq IntConstant.vtype() {
		return super.vtype().join(IntegerType.get());
	}

	eq StringConstant.vtype() {
		return super.vtype().join(StringType.get());
	}

	eq PredicateRef.vtype() {
		return super.vtype().join(PredicateRefType.get());
	}
}
