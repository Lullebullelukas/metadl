import java.util.TreeSet;

aspect ErrorCollection {
    coll TreeSet<String> Program.semanticErrors() [new TreeSet<String>()] with add;
    syn boolean Program.hasSemanticErrors() = !semanticErrors().isEmpty();
    syn String Program.errorReport() {
        StringBuilder sb = new StringBuilder();
        for(String err : semanticErrors()) sb.append(err).append("\n");
        return sb.toString();
    }

    coll TreeSet<String> Program.typeCheckErrors() [new TreeSet<String>()] with add;
    syn boolean Program.hasTypeErrors() = !typeCheckErrors().isEmpty();
    syn String Program.typeErrorReport() {
        StringBuilder sb = new StringBuilder();
        for(String err : typeCheckErrors()) sb.append(err).append("\n");
        return sb.toString();
    }

    Literal contributes "Non-ground fact: " + this
        when !isGround() && isFact()
        to Program.semanticErrors();

    Rule contributes "Unbound variable(s): " + unboundVariables() + " in " + this
        when !unboundVariables().isEmpty()
        to Program.semanticErrors();

    NEGLiteral contributes "Free variable(s) " + freeVars() + " in " + this + " in rule " + clause()
        when !freeVars().isEmpty()
        to Program.semanticErrors();

    Functor contributes "Free variable(s) " + freeVars() + " in " + this + " in rule " + occuresIn().clause()
        when !freeVars().isEmpty()
        to Program.semanticErrors();

	// predefined literals must be ground
	Literal contributes getPredicate().getPRED_ID() + " predicate must be ground." when
		isPredefined() && !isGround() to Program.semanticErrors();

	// predefined literals must appear only in the head
	Literal contributes getPredicate().getPRED_ID() + " predicate can be used only in a rule's head." when
		isPredefined() && !isDef() to Program.semanticErrors();
}
