import org.jgrapht.alg.util.UnionFind;
import java.util.stream.IntStream;
import java.util.stream.StreamSupport;
import org.apache.commons.collections4.SetUtils;

aspect DomainSeparation {
	public class DomainSignature<T> extends UnionFind<T> {
		private Set<T> elems = new HashSet<>();

		public DomainSignature(Set<T> e) {
			super(e);
			elems.addAll(e);
		}

		public DomainSignature(Collection<T> c) {
			this(new HashSet<>(c));
		}

		// Create a domain signature with the same equivalence
		// classes as sig
		public DomainSignature(DomainSignature<T> sig) {
			super(sig.elems);
			elems.addAll(sig.elems);
			for (T e : sig.elems) {
				union(e, sig.find(e));
			}
		}

		// create a new signature where i <=> j are in the same equivalence class iff
		// i <=> j in s1 and i <=> j in s2.

		public static <T extends Comparable> DomainSignature<T> merge(DomainSignature<T> s1, DomainSignature<T> s2) {
			assert s1.elems.equals(s2.elems);
			DomainSignature<T> ret = new DomainSignature<T>(s1.elems);
			for (T e1 : s1.elems) {
				for (T e2 : s2.elems) {
					if (s1.inSameSet(e1, e2) &&
						s2.inSameSet(e1, e2)) {
						ret.union(e1, e2);
					}
				}
			}
			return ret;
		}

		@Override public void addElement(T e) {
			elems.add(e);
			super.addElement(e);
		}

		@Override public boolean equals(Object o) {
			if (o == this)
				return true;
			if (!(o instanceof DomainSignature))
				return false;
			DomainSignature<T> other = (DomainSignature<T>) o;
			return equivalenceSets().equals(other.equivalenceSets());
		}

		public Set<Set<T>> equivalenceSets() {
			Map<T, Set<T>> m = new HashMap<>();
			for (T e : elems) {
				T r = find(e);
				Set<T> s = m.get(r);
				if (s == null) {
					s = new HashSet<T>();
					m.put(r, s);
				}
				s.add(e);
			}
			return new HashSet<>(m.values());
		}

		@Override public String toString() {
			return equivalenceSets().toString();
		}
	}

	syn DomainSignature<Integer> FormalPredicate.initialDomainSignature() {
		// program representation predicates have their own signatures
		if (getProgramRepresentationKind().isPresent()) {
			return programRepresentationDomainSignature(getProgramRepresentationKind().get());
		}

		DomainSignature<Integer> dom = new DomainSignature<Integer>(Collections.emptySet());
		// add all the indices that have AST type to the same domain
		int first = -1;
		for (int i : astIndices()) {
			dom.addElement(i);
			if (first != -1) {
				dom.union(first, i);
			} else {
				first = i;
			}
		}

		return dom;
	}

	syn lazy java.util.List<Integer> FormalPredicate.astIndices() {
		java.util.List<Integer> l = new ArrayList<>();
		for (int i = 0; i < type().arity(); i++) {
			if (type().get(i) == ASTNodeType.get())
				l.add(i);
		}
		return l;
	}

	syn lazy java.util.List<Integer> Literal.astIndices() =
		getPredicate().formalpredicate().astIndices();

	inh String Wildcard.freshVariableName();
	eq Literal.getTerms(int i).freshVariableName() {
		return "w_" + i + "_" + positionInRule();
	}

	/**
		dsName = a name to use for the domain separation algoriths;
		for Variables, this is their actual name, while for Wildcards it
		fresh name for each.
	 */
	syn String CommonVariable.dsName();
	eq Variable.dsName() = getVAR_ID();
	eq Wildcard.dsName() = freshVariableName();

	syn lazy Set<String> Literal.astVariables() =
		astIndices().stream().map(i -> ((CommonVariable) getTerms(i)).dsName()).collect(Collectors.toSet());

	syn DomainSignature<Integer> FormalPredicate.domainSignature() circular [initialDomainSignature()] {
		// iterate over all the heads and merge their signatures
		DomainSignature<Integer> predSig = new DomainSignature<>(domainSignature());
		for (Literal l : literals()) {
			if (l.isDef() && l.clause() instanceof Rule) {
				DomainSignature<Integer> literalSig = new DomainSignature<>(astIndices());
				DomainSignature<String> clauseSig = ((Rule)l.clause()).domainSignature();
				for (int i : l.astIndices()) {
					String vi = ((CommonVariable)l.getTerms(i)).dsName();
					for (int j : l.astIndices()) {
						String vj = ((CommonVariable)l.getTerms(j)).dsName();
						if (clauseSig.inSameSet(vi, vj))
							literalSig.union(i, j);
					}
				}
				predSig = DomainSignature.merge(predSig, literalSig);
			}
		}
		return predSig;
	}

	private DomainSignature<String> Rule.initialDomainSignature() {
		// initially all the variables have their own domain
		DomainSignature<String> dom = new DomainSignature<String>(Collections.emptySet());

		SortedSet<String> varNames = new TreeSet<>();
		for (CommonLiteral c : getHeadss()) {
			Literal l = c.asLiteral();
			if (l != null ) {
				varNames.addAll(((Literal) l).astVariables());
			}
		}

		for (CommonLiteral c : getBodys()) {
			Literal l = c.asLiteral();
			if (l != null) {
				varNames.addAll(((Literal) l).astVariables());
			}
		}

		varNames.forEach(v -> dom.addElement(v));

		return dom;
	}

	syn Literal CommonLiteral.asLiteral();
	eq Literal.asLiteral() = this;
	eq Pattern.asLiteral() = getLiteral();
	eq Constraint.asLiteral() = null;

	syn DomainSignature<String> Rule.domainSignature() circular [initialDomainSignature()] {
		DomainSignature<String> ruleSig = initialDomainSignature();

		for (CommonLiteral c : getBodys()) {
			if (c.hasNot())
				continue;

			Literal l = c.asLiteral();
			if (l == null)
				continue;

			DomainSignature<Integer> literalSig = l.getPredicate().formalpredicate().domainSignature();
			for (int i : l.astIndices()) {
				String vi = ((CommonVariable)l.getTerms(i)).dsName();
				for (int j : l.astIndices()) {
					String vj = ((CommonVariable)l.getTerms(j)).dsName();
					if (literalSig.inSameSet(i, j))
						ruleSig.union(vi, vj);
				}
			}
		}
		return ruleSig;
	}

	public void Program.dumpDomainSignatures(PrintStream ps) {
		for (FormalPredicate p : getFormalPredicates()) {
			ps.print(p.getPRED_ID() + " : " + p.type());
			ps.println(" " + p.domainSignature().equivalenceSets());
		}
	}

	// A predicate is local iff its relation can be computed separately for each
	// translation unit.
	syn boolean FormalPredicate.isLocal() circular [true] {
		if (getContextPredicateType() != null) {
			// this is a context predicate and all context predicates are local
			return true;
		}

		for (Clause c : definedIn()) {
			if (!c.isLocal()) {
				return false;
			}
		}
		return true;
	}

	// A clause is local iff it can be computed for each translation unit
	// in separation.
	syn boolean Clause.isLocal() circular [true];
	eq Fact.isLocal() = true;
	eq Rule.isLocal() {
		java.util.List<Literal> astLiterals = new ArrayList<>();

		// all the AST literals are single domain
		for (CommonLiteral c : getBodys()) {
			Literal l = c.asLiteral();
			if (l == null)
				continue;
			FormalPredicate pred = l.getPredicate().formalpredicate();
			// this rule uses a non-local predicate
			if (!pred.isLocal())
				return false;
			if (pred.isASTPredicate()) {
				// check that the predicate has exactly one equivalence set;
				// this means that the predicate contains information about
				// exactly one AST and has witnesses for that
				if (l.astVariables().isEmpty())
					return false;

				// ensure that all AST variables are in the same domain, either
				// constrained by the predicate, or constrained by other variables
				// in the clause.
				DomainSignature<Integer> literalSig = l.getPredicate().formalpredicate().domainSignature();

				for (int i : l.astIndices()) {
					String vi = ((CommonVariable)l.getTerms(i)).dsName();
					for (int j : l.astIndices()) {
						String vj = ((CommonVariable)l.getTerms(j)).dsName();
						if (!literalSig.inSameSet(i, j) && !domainSignature().inSameSet(vi, vj))
							return false;
					}
				}

				// collect the literals that depend on AST facts
				astLiterals.add(l);
			}
		}

		// no literals depend on AST, then this can be computed locally
		// (or globally), it doesn't matter.
		if (astLiterals.isEmpty())
			return true;

		// some literals depend on the AST, check that they are all connected
		DomainSignature<Literal> s = new DomainSignature<>(astLiterals);
		for (int i = 0; i < astLiterals.size(); ++i) {
			Literal li = astLiterals.get(i);
			for (int j = i + 1; j < astLiterals.size(); ++j) {
				Literal lj = astLiterals.get(j);
				if (!SetUtils.intersection(li.astVariables(), lj.astVariables()).isEmpty())
					s.union(li, lj);
			}
		}

		return s.equivalenceSets().size() == 1;
	}

	syn boolean FormalPredicate.initialIsASTPredicate() {
		// Only the program representation predicates are
		// AST predicates
		if (getProgramRepresentationKind().isPresent())
			return true;
		return false;
	}

	syn Set<FormalPredicate> Clause.predicateUses();
	eq Fact.predicateUses() = Collections.emptySet();
	eq Rule.predicateUses() {
		Set<FormalPredicate> res = new HashSet<>();
		for (CommonLiteral c : getBodys()) {
			Literal l = c.asLiteral();
			if (l != null) {
				res.add(l.getPredicate().formalpredicate());
			}
		}
		return res;
	}

	// A clause is an AST clause if it depends on any AST-derived predicates
	syn boolean Clause.isASTClause() circular [false] {
		for (FormalPredicate fp : predicateUses())
			if (fp.isASTPredicate())
				return true;
		return false;
	}

	// A predicate is an AST predicate if it depends (transitively) on any AST facts
	syn boolean FormalPredicate.isASTPredicate() circular [initialIsASTPredicate()] {
		for (Clause c : definedIn()) {
			if (c.isASTClause())
				return true;
		}
		return isASTPredicate();
	}

	syn Set<Integer> FormalPredicate.initialLocalTerms() {
		if (getProgramRepresentationKind().isPresent()) {
			// By convention, use the equivalence class of the first term with AST node type,
			// if that exists.
			// This accidentally matches the predicates we have for Java. For more
			// flexibility we should delegate this selection to the analyzed language.
			return domainSignature().equivalenceSets().stream().min((d1, d2) -> Integer.compare(Collections.min(d1), Collections.min(d2)))
				.orElse(Collections.emptySet());
		}
		return Set.copyOf(astIndices());
	}

	syn Set<Integer> FormalPredicate.localTerms() circular [initialLocalTerms()] {
		Set<Integer> currentLocalTerms = localTerms();
		// iterate over all the definitions of this predicate
		for (Literal l : literals()) {
			if (l.isDef() && l.clause() instanceof Rule) {
				Rule r = (Rule) l.clause();
				Set<String> localVariables = r.localVariables();
				Set<Integer> localTerms = new HashSet<Integer>();
				for (int i : l.astIndices()) {
					String vi = ((CommonVariable)l.getTerms(i)).dsName();
					if (localVariables.contains(vi)) {
						for (int j : l.astIndices()) {
							if (domainSignature().inSameSet(i, j)) {
								localTerms.add(j);
							}
						}
					}
				}
				currentLocalTerms = SetUtils.intersection(localTerms, currentLocalTerms);
			}
		}
		return currentLocalTerms;
	}

	/**
	   The intersection for of all the local variables for each predicate in the clause
	 */
	syn Set<String> Clause.localVariables() circular [Collections.emptySet()];
	eq Fact.localVariables() = Collections.emptySet();
	eq Rule.localVariables() {
		return StreamSupport.stream(getBodys().spliterator(), false).map(CommonLiteral::asLiteral).filter(l -> l != null)
			.map(l -> l.astIndices().stream()
				 .filter(i -> l.getPredicate().formalpredicate().localTerms().contains(i))
				 .map(i -> ((CommonVariable) l.getTerms(i)).dsName())
				 .collect(Collectors.toSet()))
			.reduce((s1, s2) -> SetUtils.intersection(s1, s2)).orElse(Collections.emptySet());
	}

	syn lazy boolean FormalPredicate.hasLocalUse() {
		for (PredicateSymbol p : predicates()) {
			Clause c = p.parentLiteral().clause();
			if (p.parentLiteral().isUse() && c.isLocal())
				return true;
		}
		return false;
	}

	syn lazy boolean FormalPredicate.hasGlobalUse() {
		for (PredicateSymbol p : predicates()) {
			Clause c = p.parentLiteral().clause();
			if (p.parentLiteral().isUse() && !c.isLocal())
				return true;
		}
		return false;
	}

	syn lazy boolean FormalPredicate.hasLocalDef() {
		for (PredicateSymbol p : predicates()) {
			Clause c = p.parentLiteral().clause();
			if (p.parentLiteral().isDef() && c.isLocal())
				return true;
		}
		return false;
	}

	syn lazy boolean FormalPredicate.hasGlobalDef() {
		for (PredicateSymbol p : predicates()) {
			Clause c = p.parentLiteral().clause();
			if (p.parentLiteral().isDef() && !c.isLocal())
				return true;
		}
		return false;
	}
}
