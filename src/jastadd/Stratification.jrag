import org.jgrapht.graph.DefaultDirectedGraph;
import org.jgrapht.Graph;
import org.jgrapht.graph.DefaultEdge;
import org.jgrapht.alg.connectivity.KosarajuStrongConnectivityInspector;
import org.jgrapht.alg.interfaces.StrongConnectivityAlgorithm;
import org.jgrapht.nio.dot.DOTExporter;
import org.jgrapht.traverse.TopologicalOrderIterator;
import java.util.LinkedHashSet;
import java.io.FileWriter;
import eval.Stratum;

aspect Stratification {
	public class PredicateDependencyGraph extends DefaultDirectedGraph<FormalPredicate, DefaultEdge> {
		PredicateDependencyGraph() {
			super(DefaultEdge.class);
		}

		public void addEdge(Pair<Collection<FormalPredicate>, Collection<FormalPredicate>> es) {
			for (FormalPredicate from : es.getLeft())
				addVertex(from);
			for (FormalPredicate to : es.getRight())
				addVertex(to);
			for (FormalPredicate from : es.getLeft()) {
				for (FormalPredicate to : es.getRight()) {
					addEdge(from, to);
				}
			}
		}

		public void dump() throws IOException {
			DOTExporter<FormalPredicate, DefaultEdge> dotEx = new DOTExporter<>(v -> v.getPRED_ID());
			dotEx.exportGraph(this, new FileWriter("pdg.dot"));

			StrongConnectivityAlgorithm<FormalPredicate, DefaultEdge> sc =
				new KosarajuStrongConnectivityInspector<>(this);

			DOTExporter<Graph<FormalPredicate, DefaultEdge>, DefaultEdge> dotEx2 = new DOTExporter<>();

			dotEx2.exportGraph(sc.getCondensation(), new FileWriter("scc.dot"));
		}
	}

	/**
	   predicateDependencyGraph = a graph with vertices representing the predicates of the program and
	   edges the data-dependencies between these predicates. The graph contains an edge P -> Q iff
	   the Datalog program contains a rule ..., Q, ... :- ... , P, ... .
	 */
	coll PredicateDependencyGraph Program.predicateDependencyGraph() [new PredicateDependencyGraph()] with addEdge;
	coll Set<Clause> FormalPredicate.definedIn() [new LinkedHashSet<Clause>()];

	private Pair<Collection<FormalPredicate>, Collection<FormalPredicate>> Rule.pdgContribution() {
		Set<FormalPredicate> from = new HashSet<>();
		Set<FormalPredicate> to = new HashSet<>();

		for (CommonLiteral h : getHeadss()) {
			if (h instanceof Literal) {
				to.add(((Literal) h).getPredicate().formalpredicate());
			}
		}

		for (CommonLiteral t : getBodys()) {
			if (t instanceof Literal) {
				from.add(((Literal) t).getPredicate().formalpredicate());
			}
		}
		return Pair.of(from, to);
	}

	Rule contributes pdgContribution() to Program.predicateDependencyGraph();
	AnalyzeBlock contributes nta getExpandedClauses() to Program.predicateDependencyGraph();

	Literal contributes clause() when isDef() to FormalPredicate.definedIn() for getPredicate().formalpredicate();
	AnalyzeBlock contributes nta getExpandedClauses() to FormalPredicate.definedIn();

	syn java.util.List<Stratum> Program.strata(EvaluationContext ctx) {
		java.util.List<Stratum> strata = new ArrayList<>();

		Graph<FormalPredicate, DefaultEdge> pdg = predicateDependencyGraph();

		StrongConnectivityAlgorithm<FormalPredicate, DefaultEdge> sca =
			new KosarajuStrongConnectivityInspector<>(pdg);

		TopologicalOrderIterator<Graph<FormalPredicate, DefaultEdge>, DefaultEdge> it = new
			TopologicalOrderIterator<>(sca.getCondensation());

		while (it.hasNext()) {
			Graph<FormalPredicate, DefaultEdge> scc = it.next();
			java.util.List<FormalPredicate> orderedPreds = new ArrayList<>(scc.vertexSet());
			Collections.sort(orderedPreds, (l, r) -> l.getPRED_ID().compareTo(r.getPRED_ID()));

			// relations in the current stratum
			java.util.List<Relation2> rels = orderedPreds.stream()
				.map(p -> p.relation2()).collect(Collectors.toList());

			// control statements in the current stratum
			java.util.List<Control> stmts = new ArrayList<>();
			for (FormalPredicate p : orderedPreds) {
				for (Clause c : p.definedIn()) {
					stmts.add(c.genCode(ctx));
				}
			}

			if (orderedPreds.size() == 1 &&
				!pdg.containsEdge(orderedPreds.get(0), orderedPreds.get(0))) {
				// the stratum contains a single predicate; if it does not depend on
				// itself, then it's safe to evaluate all its rules only once
				strata.add(Stratum.single(rels, stmts));
			} else {
				strata.add(Stratum.fixpoint(rels, stmts));
			}
		}

		return strata;
	}

	public void Program.dumpStrata() throws IOException {
		PrintStream f = new PrintStream("strata.dump");
		EvaluationContext ctx = new EvaluationContext();

		for (Stratum s : strata(ctx)) {
			s.prettyPrint(f);
			f.println();
		}
		f.close();
	}
}
