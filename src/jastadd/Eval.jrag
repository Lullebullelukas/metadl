import java.util.stream.Collectors;
import org.apache.commons.collections4.SetUtils;
import java.util.LinkedList;
import java.util.ListIterator;

aspect Eval {


	/**
		Removal of self-join variables

		Transform A(x, x, y, y) to A(x, x', y, y'), EQ(x, x'). EQ(y, y').
	*/

	/**
	   The presence of this variables introduces a self-join.
	   E.g.  In A(x, x), the second occurence of x is a self-join variable.
	 */
	inh boolean Variable.isSelfJoinVariable();
	eq CommonLiteral.getChild().isSelfJoinVariable() = false;
	eq Literal.getTerms(int i).isSelfJoinVariable() {
		if (!isUse())
			return false;

		if (!getTerms(i).isVariable())
			return false;

		for (int j = 0; j < i; j++) {
			if (getTerms(j).isVariable()) {
				Variable v = (Variable) getTerms(j);
				if (v.getVAR_ID().equals(((Variable) getTerms(i)).getVAR_ID()))
					return true;
			}
		}

		return false;
	}

	syn boolean Literal.isSelfJoin() {
		if (hasNot())
			return false;

		for (Term t : getTermss()) {
			if (t.isVariable() && ((Variable) t).isSelfJoinVariable())
				return true;
		}
		return false;
	}

	inh int CommonLiteral.positionInRule();
	eq Rule.getBody(int i).positionInRule() = i;

	/**
	   nameForDuplicateVar = fresh name to be used for duplicate variable
	 */
	inh String Variable.nameForDuplicateVar();
	eq Literal.getTerms(int i).nameForDuplicateVar() {
		Variable v = (Variable) getTerms(i);
		return "j_" + v.getVAR_ID() + i + "_" + positionInRule();
	}

	/**
	   Literals for evaluation
	 */
	syn java.util.List<CommonLiteral> CommonLiteral.evalLiterals() = Collections.emptyList();
	eq Literal.evalLiterals() {
		if (!isSelfJoin())
			return Collections.singletonList(this);

		java.util.List<CommonLiteral> ret = new ArrayList<>();
		Literal l = new Literal(getPredicate().treeCopy(), new List<>());

		ret.add(l);

		for (Term t : getTermss()) {
			if (t.isVariable()) {
				Variable v = (Variable) t;
				if (v.isSelfJoinVariable()) {
					// Create a fresh variable
					Variable v1 = new Variable(v.nameForDuplicateVar());
					l.addTerms(v1);
					// Introduce a constraint
					ret.add(Constructors.EQ(new Variable(v.getVAR_ID()),
											new Variable(v.nameForDuplicateVar())));
				} else {
					l.addTerms(t.treeCopy());
				}
			} else {
				l.addTerms(t.treeCopy());
			}
		}

		return ret;
	}

	syn Set<String> CommonLiteral.boundVariableNames() =
		boundVariables().stream().map(v -> v.getVAR_ID()).collect(Collectors.toSet());

	syn Set<String> CommonLiteral.variableNames() =
		variables().stream().map(v -> v.getVAR_ID()).collect(Collectors.toSet());

	eq Pattern.evalLiterals() = Collections.singletonList(getLiteral());
	eq Constraint.evalLiterals() = Collections.singletonList(this);

	private boolean Rule.trySchedule(CommonLiteral l, java.util.List<CommonLiteral> postponed,
									 java.util.List<CommonLiteral> schedule,
									 Set<String> boundSoFar) {
		if (SetUtils.difference(l.variableNames(), l.boundVariableNames()).isEmpty()) {
			// this means that positive Literals are added to the schedule in the order
			// in which they appear in the clause, while Constraints may be postponed,
			// such that they are evaluated when all the variables are bound
			schedule.add(l);
			boundSoFar.addAll(l.variableNames());
			return true;
		} else if (SetUtils.difference(l.variableNames(), boundSoFar).isEmpty()) {
			schedule.add(l);
			return true;
		} else {
			postponed.add(l);
			return false;
		}
	}

	syn java.util.List<CommonLiteral> Rule.evalSchedule() {
		java.util.List<CommonLiteral> postponed = new LinkedList<>();
		java.util.List<CommonLiteral> schedule = new ArrayList<>();
		Set<String> boundSoFar = new HashSet<>();
		for (CommonLiteral bs : getBodys()) {
			// Try to schedule any postponed literals
			ListIterator<CommonLiteral> it = schedule.listIterator();
			while (it.hasNext()) {
				CommonLiteral candidate = it.next();
				if (trySchedule(candidate, postponed, schedule, boundSoFar))
					it.remove();
			}

			// Schedule the current literal
			for (CommonLiteral l : bs.evalLiterals()) {
				trySchedule(l, postponed, schedule, boundSoFar);
			}
		}
		return schedule;
	}

	/**
	   Assign variable names in the order in which they appear
	   in the schedule. This allows us to keep track of the bound
	   variables by using a single integer instead of a set.
	 */
	syn Map<String, Integer> Rule.evalVariables() {
		int i = 0;
		Map<String, Integer> varMap = new HashMap<>();
		for (CommonLiteral l : evalSchedule()) {
			for (Variable v : l.variables()) {
				if (!varMap.containsKey(v.getVAR_ID())) {
					varMap.put(v.getVAR_ID(), i);
					i++;
				}
			}
		}
		return varMap;
	}
}
