import java.util.stream.Collectors;
import org.apache.commons.collections4.SetUtils;
import org.apache.commons.lang3.tuple.Pair;
import java.util.LinkedList;
import java.util.ListIterator;
import eval.Control;
import eval.Relation2;
import eval.Tuple;
import eval.EvaluationContext;
import eval.Operation;

aspect Eval {


	/**
		Removal of self-join variables

		Transform A(x, x, y, y) to A(x, x', y, y'), EQ(x, x'). EQ(y, y').
	*/

	/**
	   The presence of this variables introduces a self-join.
	   E.g.  In A(x, x), the second occurence of x is a self-join variable.
	 */
	inh boolean Variable.isSelfJoinVariable();
	eq CommonLiteral.getChild().isSelfJoinVariable() = false;
	eq Literal.getTerms(int i).isSelfJoinVariable() {
		if (!isUse())
			return false;

		if (!getTerms(i).isVariable())
			return false;

		for (int j = 0; j < i; j++) {
			if (getTerms(j).isVariable()) {
				Variable v = (Variable) getTerms(j);
				if (v.getVAR_ID().equals(((Variable) getTerms(i)).getVAR_ID()))
					return true;
			}
		}

		return false;
	}

	syn boolean Literal.isSelfJoin() {
		if (hasNot())
			return false;

		for (Term t : getTermss()) {
			if (t.isVariable() && ((Variable) t).isSelfJoinVariable())
				return true;
		}
		return false;
	}

	inh int CommonLiteral.positionInRule();
	eq Rule.getBody(int i).positionInRule() = i;

	/**
	   nameForDuplicateVar = fresh name to be used for duplicate variable
	 */
	inh String Variable.nameForDuplicateVar();
	eq Literal.getTerms(int i).nameForDuplicateVar() {
		Variable v = (Variable) getTerms(i);
		return "j_" + v.getVAR_ID() + i + "_" + positionInRule();
	}

	/**
	   Literals for evaluation
	 */
	syn java.util.List<CommonLiteral> CommonLiteral.evalLiterals() = Collections.emptyList();
	eq Literal.evalLiterals() {
		if (!isSelfJoin())
			return Collections.singletonList(this);

		java.util.List<CommonLiteral> ret = new ArrayList<>();
		Literal l = new Literal(getPredicate().treeCopy(), new List<>());

		ret.add(l);

		for (Term t : getTermss()) {
			if (t.isVariable()) {
				Variable v = (Variable) t;
				if (v.isSelfJoinVariable()) {
					// Create a fresh variable
					Variable v1 = new Variable(v.nameForDuplicateVar());
					l.addTerms(v1);
					// Introduce a constraint
					ret.add(Constructors.EQ(new Variable(v.getVAR_ID()),
											new Variable(v.nameForDuplicateVar())));
				} else {
					l.addTerms(t.treeCopy());
				}
			} else {
				l.addTerms(t.treeCopy());
			}
		}

		return ret;
	}

	syn Set<String> CommonLiteral.boundVariableNames() =
		boundVariables().stream().map(v -> v.getVAR_ID()).collect(Collectors.toSet());

	syn Set<String> CommonLiteral.variableNames() =
		variables().stream().map(v -> v.getVAR_ID()).collect(Collectors.toSet());

	eq Pattern.evalLiterals() = Collections.singletonList(getLiteral());
	eq Constraint.evalLiterals() = Collections.singletonList(this);

	private boolean Rule.trySchedule(CommonLiteral l, java.util.List<CommonLiteral> postponed,
									 java.util.List<CommonLiteral> schedule,
									 Set<String> boundSoFar) {
		if (SetUtils.difference(l.variableNames(), l.boundVariableNames()).isEmpty()) {
			// this means that positive Literals are added to the schedule in the order
			// in which they appear in the clause, while Constraints may be postponed,
			// such that they are evaluated when all the variables are bound
			schedule.add(l);
			boundSoFar.addAll(l.variableNames());
			return true;
		} else if (SetUtils.difference(l.variableNames(), boundSoFar).isEmpty()) {
			schedule.add(l);
			return true;
		} else {
			postponed.add(l);
			return false;
		}
	}

	syn java.util.List<CommonLiteral> Rule.evalSchedule() {
		java.util.List<CommonLiteral> postponed = new LinkedList<>();
		java.util.List<CommonLiteral> schedule = new ArrayList<>();
		Set<String> boundSoFar = new HashSet<>();
		for (CommonLiteral bs : getBodys()) {
			// Try to schedule any postponed literals
			ListIterator<CommonLiteral> it = schedule.listIterator();
			while (it.hasNext()) {
				CommonLiteral candidate = it.next();
				if (trySchedule(candidate, postponed, schedule, boundSoFar))
					it.remove();
			}

			// Schedule the current literal
			for (CommonLiteral l : bs.evalLiterals()) {
				trySchedule(l, postponed, schedule, boundSoFar);
			}
		}
		return schedule;
	}

	/**
	   Assign variable names in the order in which they appear
	   in the schedule. This allows us to keep track of the bound
	   variables by using a single integer instead of a set.
	 */
	syn Map<String, Integer> Clause.evalVariables();
	eq Rule.evalVariables() {
		int i = 0;
		Map<String, Integer> varMap = new HashMap<>();
		for (CommonLiteral l : evalSchedule()) {
			for (Variable v : l.variables()) {
				if (!varMap.containsKey(v.getVAR_ID())) {
					varMap.put(v.getVAR_ID(), i);
					i++;
				}
			}
		}
		return varMap;
	}
	eq Fact.evalVariables() = Collections.emptyMap();

	/**
	   evalTuple = Tuple to hold variable's values while evaluating the current clause
	 */
	syn Tuple Clause.evalTuple() = new Tuple(evalVariables().size());

	/**
	   Generate a statement sequence for the clause
	 */
	syn Control Clause.genCode(EvaluationContext ctx);

	eq Fact.genCode(EvaluationContext ctx) {
		Tuple t = evalTuple();
		Control currentCont = Control.nop();
		Set<String> boundVars = Collections.emptySet();

		for (CommonLiteral h : getHeadss()) {
			currentCont = h.genCode(t, ctx, currentCont, boundVars);
		}

		return currentCont;
	}

	eq Rule.genCode(EvaluationContext ctx) {

		Tuple t = evalTuple();
		Control currentCont = Control.nop();
		Set<String> boundVars = new HashSet<>();

		for (CommonLiteral h : getHeadss()) {
			currentCont = h.genCode(t, ctx, currentCont, boundVars);
		}


		for (CommonLiteral b : evalSchedule()) {
			currentCont = b.genCode(t, ctx, currentCont, boundVars);
		}

		return currentCont;
	}

	protected Control CommonLiteral.genCode(Tuple t, EvaluationContext ctx, Control cont, Set<String> boundVars) {
		return Control.nop();
	}

	syn int Variable.varId() {
		return literal().clause().evalVariables().get(getVAR_ID());
	}

	/**
	   constVal = value of constant, internalized in the case of predicate symbols
	   and strings
	 */
	syn long Constant.constVal(EvaluationContext ctx);
	eq IntConstant.constVal(EvaluationContext ctx) = Long.parseLong(getNUMERAL());
	eq PredicateRef.constVal(EvaluationContext ctx) = ctx.internalizeString(getPRED_ID());
	eq StringConstant.constVal(EvaluationContext ctx) = ctx.internalizeString(getSTRING());

	private Control Literal.genCodePositiveLiteral(Tuple t, Relation2 rel, EvaluationContext ctx, Control cont, Set<String> boundVars) {
		java.util.List<Pair<Integer, Integer>> assign = new ArrayList<>();
		java.util.List<Pair<Integer, Long>> consts = new ArrayList<>();
		java.util.List<Pair<Integer, Integer>> test = new ArrayList<>();

		if (isDef()) {
			// literal in the head
			for (int i = 0; i < getNumTerms(); ++i) {
				if (getTerms(i).isVariable()) {
					assign.add(Pair.of(i, ((Variable) getTerms(i)).varId()));
				} else {
					assert getTerms(i).isConstant();
					consts.add(Pair.of(i, ((Constant) getTerms(i)).constVal(ctx)));
				}
			}
			return Control.insert(t, rel, assign, consts, cont);
		} else {
			// literal in the body
			for (int i = 0; i < getNumTerms(); ++i) {
				if (getTerms(i).isVariable()) {
					Variable v = (Variable) getTerms(i);
					if (boundVars.contains(v.getVAR_ID())) {
						// the variable is bound by previous literals, so use its value for lookup
						test.add(Pair.of(i, v.varId()));
					} else {
						// the variable is free, assign it a value and mark it as bound
						boundVars.add(v.getVAR_ID());
						assign.add(Pair.of(i, v.varId()));
					}
				} else if (getTerms(i).isConstant()) {
					// ground terms
					consts.add(Pair.of(i, ((Constant) getTerms(i)).constVal(ctx)));
				} else {
					// do nothing for wildcards
				}
			}
			return Control.forAll(t, rel, test, consts, assign, cont);
		}
	}

	private Control Literal.genCodeNegativeLiteral(Tuple t, Relation2 rel, EvaluationContext ctx, Control cont) {
		java.util.List<Pair<Integer, Integer>> assign = new ArrayList<>();
		java.util.List<Pair<Integer, Long>> consts = new ArrayList<>();
		java.util.List<Pair<Integer, Integer>> test = new ArrayList<>();

		for (int i = 0; i < getNumTerms(); ++i) {
			if (getTerms(i).isVariable()) {
				test.add(Pair.of(i, ((Variable) getTerms(i)).varId()));
			} else if (getTerms(i).isConstant()) {
				consts.add(Pair.of(i, ((Constant) getTerms(i)).constVal(ctx)));
			}
		}

		return Control.ifNotExists(t, rel, test, consts, cont);
	}

	protected Control Literal.genCode(Tuple t, EvaluationContext ctx, Control cont, Set<String> boundVars) {
		Relation2 rel = getPredicate().formalpredicate().relation2();
		if (hasNot()) {
			return genCodeNegativeLiteral(t, rel, ctx, cont);
		} else {
			return genCodePositiveLiteral(t, rel, ctx, cont, boundVars);
		}
	}

	protected Control BINDLiteral.genCode(Tuple t, EvaluationContext ctx, Control cont, Set<String> boundVars) {
		Variable dst = (Variable) getExpr(0);
		boundVars.add(dst.getVAR_ID());
		return Control.bind(t, cont, dst.varId(), getExpr(1).genCode(t, ctx));
	}

	public abstract Operation Expr.genCode(Tuple t, EvaluationContext ctx);
	@Override public Operation Functor.genCode(Tuple t, EvaluationContext ctx) {
		Operation arg0 = getArg(0).genCode(t, ctx);
		Operation arg1 = getArg(1).genCode(t, ctx);

		switch (getFunc().getFUNC_ID()) {
		case "add":
			return Operation.add(arg0, arg1);
		case "mul":
			return Operation.mul(arg0, arg1);
		case "sub":
			return Operation.sub(arg0, arg1);
		case "div":
			return Operation.div(arg0, arg1);
		case "mod":
			return Operation.mod(arg0, arg1);
		default:
			throw new RuntimeException("Functor not implemented: " + getFunc().getFUNC_ID());
		}
	}
	@Override public Operation Variable.genCode(Tuple t, EvaluationContext ctx) {
		return Operation.component(t, varId());
	}
	@Override public Operation Constant.genCode(Tuple t, EvaluationContext ctx) {
		return Operation.constant(constVal(ctx));
	}
	@Override public Operation Wildcard.genCode(Tuple t, EvaluationContext ctx) {
		return null;
	}

	syn Relation2 FormalPredicate.relation2() {
		return new Relation2(realArity());
	}
}
