import lang.relation.Relation;
import lang.relation.PseudoTuple;
import java.util.ArrayList;
import java.lang.reflect.ParameterizedType;


aspect DatalogProject {
	public String ASTNode.getRelation() {
		String nodeName = this.getClass().getName();
		String[] splitNodeName = nodeName.split("\\.");
		return splitNodeName[splitNodeName.length - 1];
	}

	public int ASTNode.UID = 0;
	public static int ASTNode.RunningId = 0;

	public synchronized int ASTNode.getNodeId() {
		if (UID == 0) {
			UID = ++ASTNode.RunningId;
		}
		return UID;
	}

	public class TupleWrapper {
		public class RelationTuple {
			String relation;
			PseudoTuple tuple;
			public RelationTuple(String relation, PseudoTuple tuple) {
				this.relation = relation;
				this.tuple = tuple;
			}
		}

		public ArrayList<RelationTuple> tuples = new ArrayList<>();
		public String defaultRel;

		TupleWrapper() {}

		TupleWrapper(String defaultRel) {
			this.defaultRel = defaultRel;
		}

		public void addTuple(PseudoTuple tpl) {
			assert defaultRel != null;
			tuples.add(new RelationTuple(defaultRel, tpl));
		}

		public void addTuple(String relation, PseudoTuple tpl) {
			tuples.add(new RelationTuple(relation, tpl));
		}

		public Iterable<RelationTuple> getTuples() {
			return tuples;
		}
	}

	public class RelationMap {
		public HashMap<String, Relation> nameToRelMap = new HashMap<>();
		public void add(TupleWrapper tplw) {
			for (TupleWrapper.RelationTuple tpl : tplw.getTuples()) {
				Relation r;
				r = nameToRelMap.get(tpl.relation);
				if (r == null) {
					// Create a relation if it does not exist
					r = new Relation(tpl.tuple.arity());
					nameToRelMap.put(tpl.relation, r);
				}
				r.addTuple(tpl.tuple);
			}
		}
	}

	coll RelationMap Program.datalogProjection() with add;

	public TupleWrapper ASTNode.buildTupleWrapper() {
		if (getNumChild() == 0) {
			// this is a terminal node, record it to terminals relation
			TupleWrapper ret = new TupleWrapper("Terminal");
			ret.addTuple(new PseudoTuple(new IntConstant("" + getNodeId())));
			return ret;
		}

		String relName = getRelation();
		TupleWrapper ret = new TupleWrapper(relName);

		int childIndex = 0;

		for (int i = 0; i < getNumChild(); ++i) {
			ASTNode child = getChild(i);
			if (child instanceof List) {
				List<ASTNode> childrenList = (List<ASTNode>) child;
				for (ASTNode c : childrenList) {
					IntConstant ChildId = new IntConstant("" + c.getNodeId());
					IntConstant CurrentNodeId = new IntConstant("" + getNodeId());
					IntConstant ChildIdx = new IntConstant("" + childIndex++);
					ret.addTuple(new PseudoTuple(CurrentNodeId, ChildIdx, ChildId));
				}
			} else {
				IntConstant ChildId = new IntConstant("" + child.getNodeId());
				IntConstant CurrentNodeId = new IntConstant("" + getNodeId());
				IntConstant ChildIdx = new IntConstant("" + childIndex++);
				ret.addTuple(new PseudoTuple(CurrentNodeId, ChildIdx, ChildId));
			}
		}
		return ret;
	}

	public TupleWrapper List.buildTupleWrapper() {
		// AST nodes that have variadic number of children
		// use a List as a child node. Ignore them.
		return new TupleWrapper(null);
	}

	public static TupleWrapper Constant.constantNodeHelper(Constant c, String relName) {
		TupleWrapper ret = new TupleWrapper(relName);
		IntConstant nodeId = new IntConstant("" + c.getNodeId());
		ret.addTuple(new PseudoTuple(nodeId, c));
		return ret;
	}

	public TupleWrapper IntConstant.buildTupleWrapper() {
		return constantNodeHelper(this, "IntConstant");
	}

	public TupleWrapper StringConstant.buildTupleWrapper() {
		return constantNodeHelper(this, "StringConstant");
	}

	public TupleWrapper PredicateRef.buildTupleWrapper() {
		return constantNodeHelper(this, "PredicateRef");
	}

	public TupleWrapper Variable.buildTupleWrapper() {
		TupleWrapper ret = new TupleWrapper("Variable");
		IntConstant nodeId = new IntConstant("" + getNodeId());
		StringConstant varName = new StringConstant(getVAR_ID());

		ret.addTuple(new PseudoTuple(nodeId, varName));
		return ret;
	}

	public TupleWrapper PredicateSymbol.buildTupleWrapper() {
		TupleWrapper ret = new TupleWrapper("PredicateSymbol");
		IntConstant nodeId = new IntConstant("" + getNodeId());
		StringConstant varName = new StringConstant(getPRED_ID());

		ret.addTuple(new PseudoTuple(nodeId, varName));
		return ret;
	}

	public TupleWrapper BinaryExclusiveTermLiteral.buildTupleWrapper() {
		TupleWrapper ret = new TupleWrapper("BinaryExclusiveTermLiteral");
		IntConstant nodeId = new IntConstant("" + getNodeId());
		StringConstant compOp = new StringConstant("" + getPredicate().getPRED_ID());
		IntConstant lhs = new IntConstant("" + getRight().getNodeId());
		IntConstant rhs = new IntConstant("" + getLeft().getNodeId());
		ret.addTuple(new PseudoTuple(nodeId, compOp, lhs, rhs));
		return ret;
	}

	public TupleWrapper BinExpr.exprNodeHelper(String op) {
		TupleWrapper ret = new TupleWrapper("BinExpr");
		IntConstant nodeId = new IntConstant("" + getNodeId());
		StringConstant compOp = new StringConstant(op);
		IntConstant lhs = new IntConstant("" + getRight().getNodeId());
		IntConstant rhs = new IntConstant("" + getLeft().getNodeId());
		ret.addTuple(new PseudoTuple(nodeId, compOp, lhs, rhs));
		return ret;
	}

	public TupleWrapper AddExpr.buildTupleWrapper() {
		return exprNodeHelper("+");
	}

	public TupleWrapper SubExpr.buildTupleWrapper() {
		return exprNodeHelper("-");
	}

	public TupleWrapper MulExpr.buildTupleWrapper() {
		return exprNodeHelper("*");
	}

	public TupleWrapper DivExpr.buildTupleWrapper() {
		return exprNodeHelper("/");
	}

	public TupleWrapper Rule.buildTupleWrapper() {
		TupleWrapper ret = new TupleWrapper();
		List<InclusiveLiteral> heads = getHeadss();
		List<Literal> bodys = getBodys();

		IntConstant CurrentNodeId = new IntConstant("" + getNodeId());
		int childIndex = 0;
		for (ASTNode h : heads) {
			IntConstant ChildId = new IntConstant("" + h.getNodeId());
			IntConstant ChildIdx = new IntConstant("" + childIndex++);
			ret.addTuple("Head", new PseudoTuple(CurrentNodeId, ChildIdx, ChildId));
		}
		childIndex = 0;
		for (ASTNode b : bodys) {
			IntConstant ChildId = new IntConstant("" + b.getNodeId());
			IntConstant ChildIdx = new IntConstant("" + childIndex++);
			ret.addTuple("Body", new PseudoTuple(CurrentNodeId, ChildIdx, ChildId));
		}
		return ret;
	}

	ASTNode contributes buildTupleWrapper() to Program.datalogProjection() ;

	public HashSet<String> Program.loadedPrograms = new HashSet<String>();
}
