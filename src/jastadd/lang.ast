/**
	Program
**/
Program  ::= Clause* /FormalPredicate*/;

/**
   Clause
**/
abstract Clause ::= Heads:InclusiveLiteral*;
Rule:Clause ::=  Body:Literal*;
Fact:Clause;
AnalyzeBlock:Clause ::= ProgramRef:PredicateRef Clause*;

/**
   Literals
**/
abstract Literal;
MetaAtom:Literal ::= Predicate:MetaVariable Term*;
abstract ConcreteLiteral:Literal ::= Predicate:PredicateSymbol;
/* Exclusive literals cannot appear in the head of a clause */
abstract InclusiveLiteral:ConcreteLiteral;
abstract ExclusiveLiteral:ConcreteLiteral;
abstract BinaryExclusiveTermLiteral:ExclusiveLiteral ::= Left:Expr Right:Expr;



Atom:InclusiveLiteral          ::= Terms:Term*;
EDBLiteral:InclusiveLiteral    ::= PredicateRef FileLoc:Term;
OUTPUTLiteral:InclusiveLiteral ::= Term;
PREDLiteral:InclusiveLiteral   ::= Term /PredicateRef*/;
ATOMLiteral:InclusiveLiteral   ::= Term /PredicateRef*/;
TYPEOFLiteral:InclusiveLiteral ::= PredicateRef:Term Term;
NEGLiteral:ExclusiveLiteral    ::= InclusiveLiteral;

BINDLiteral:ExclusiveLiteral ::= ConcreteVariable Right:Expr;
IMPORTLiteral:InclusiveLiteral ::= FileLoc:Term ProgramRef:PredicateRef
                                             HeadRef:PredicateRef
                                             BodyRef:PredicateRef
                                             FactRef:PredicateRef
                                             AtomRef:PredicateRef
                                             PredicateSymbolRef:PredicateRef
                                             IntConstantRef:PredicateRef
                                             StringConstantRef:PredicateRef
                                             PredicateRefRef:PredicateRef
                                             VariableRef:PredicateRef
                                             IMPORTLiteralRef:PredicateRef
                                             EDBLiteralRef:PredicateRef
                                             OUTPUTLiteralRef:PredicateRef
					     NEGLiteralRef:PredicateRef
					     BINDLiteralRef:PredicateRef
					     BinaryExclusiveTermLiteralRef:PredicateRef
					     BinExprRef:PredicateRef
					     ;

EQLiteral:BinaryExclusiveTermLiteral;
NEQLiteral:BinaryExclusiveTermLiteral;
LTLiteral:BinaryExclusiveTermLiteral;
LTELiteral:BinaryExclusiveTermLiteral;
GTLiteral:BinaryExclusiveTermLiteral;
GTELiteral:BinaryExclusiveTermLiteral;
EQLISTLiteral:ExclusiveLiteral ::= TermList;

LiteralGap:Literal;

/**
	Expressions
**/
abstract Expr;
abstract BinExpr:Expr ::= Left:Expr Right:Expr;
AddExpr:BinExpr;
SubExpr:BinExpr;
MulExpr:BinExpr;
DivExpr:BinExpr;

/**
	Types
**/
abstract Type:Constant;
abstract ConcreteType:Type;

StringType:ConcreteType;
IntegerType:ConcreteType;
PredRefType:ConcreteType;

TypeType:ConcreteType;
VariableType:ConcreteType;
ListType:Type  ::= Type;
UnknownType:Type;
BadType:Type;

/**
    Terms
**/
abstract Term:Expr;
abstract TermGap:Term;
abstract Constant:Term;
abstract Variable:Term;

MetaVariable:Term ::= <VAR_ID>;
ConcreteVariable:Term ::= <VAR_ID>;
PredicateRef:Constant   ::= <PRED_ID>;
StringConstant:Constant ::= <STRING>;
IntConstant:Constant    ::= <NUMERAL>;
TermList:Constant       ::= Terms:Term*;

/**
    PredicateSymbols
**/
FormalPredicate ::= <PRED_ID>;
PredicateSymbol ::= <PRED_ID>;

/**
   Patterns
**/
abstract MetaPattern : ExclusiveLiteral;

ClausePattern : MetaPattern ::= Clause;
LiteralPattern : MetaPattern ::= Literal;
ExprPattern : MetaPattern ::= Expr;
