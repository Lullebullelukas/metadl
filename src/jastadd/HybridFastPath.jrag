import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedList;
import java.sql.SQLException;
import java.nio.CharBuffer;

/**
 * Hybrid execution fast path
 *
 * This module checks if the MDL program matches the common structure of bug checkers,
 * i.e., almost all work being done in 'analyze' blocks and the toplevel using
 * trivial computations to determine the files to be analysed.  If so, it provides
 * a quick evaluator.
 *
 * @author creichen
 */
aspect HybridFastPath {

	public class HFPProgram {
		public static final String FILE_SUFFIX = ".hfp";

		private static final String HEADER = "MDLHFP1:";

		public static final int ANNOTATIONS_SIZE = 2;
		public static final int ANNOTATION_SOURCE_RELATION = 1;

		// Start of serialised elements
		private Op annotations;
		private Op formal_predicates;
		private Op cached_predicates;;
		private java.util.List<HFPProgram.Op> ops;
		// End of serialised elements

		private HFPProgram() {
			String[] annotations_arr = new String[HFPProgram.ANNOTATIONS_SIZE];
			for (int i = 1; i < HFPProgram.ANNOTATIONS_SIZE; ++i) {
				annotations_arr[i] = "";
			}
			this.annotations = Op.make(DECL, annotations_arr);
			this.cached_predicates = Op.make(DECL, new String[]{null});
		};

		public void
		setAnnotation(int annotation_id, String value) {
			if (value == null) {
				throw new RuntimeException("Annotations must not be null");
			}
			this.annotations.body[annotation_id] = value;
		}

		public String
		getAnnotation(int annotation_id) {
			return this.annotations.body[annotation_id];
		}

		public void
		setCachedPredicates(Program prog,
				    Collection<? extends String> cached_predicate_collection) {
			final String[] data = new String[cached_predicate_collection.size() + 1];
			int pos = 1;
			LinkedList<Op> ll = new LinkedList<>();
			for (String pred : cached_predicate_collection) {
				data[pos++] = pred;
				if (prog.formalPredicateMap().get(pred) == null) {
					throw new RuntimeException("All hands abandon ship!");
				}
				HFPProgram.addTypeInfo(ll, prog.formalPredicateMap().get(pred));
			}
			this.cached_predicates = Op.make(DECL, data);
			this.ops.addAll(ll);
			this.sortOps();
		}

		public Collection<String>
		getCachedPredicates() {
			String[] data = this.cached_predicates.body;
			ArrayList<String> result = new ArrayList<>(data.length - 1);
			for (int i = 1; i < data.length; ++i) {
				result.add(data[i]);
			}
			return result;
		}

		public String serialize() {
			System.out.println(this);
			StringBuffer sb = new StringBuffer();
			sb.append(HFPProgram.HEADER);
			this.annotations.serialize(sb);
			this.formal_predicates.serialize(sb);
			this.cached_predicates.serialize(sb);
			serializeNonnegativeInt(sb, this.ops.size());
			for (Op op : this.ops) {
				op.serialize(sb);
			}
			return sb.toString();
		}

		public static HFPProgram
		deserialize(CharSequence string) {
			CharBuffer buf;
			if (string instanceof CharBuffer) {
				buf = (CharBuffer) string;
			} else {
				buf = CharBuffer.wrap(string);
			}
			return new Deserializer(buf).getProgram();
		}

		private HFPProgram
		deserialize(Deserializer dser) {
			dser.expect(HFPProgram.HEADER);
			this.annotations = dser.getOp();
			this.formal_predicates = dser.getOp();
			this.cached_predicates = dser.getOp();
			int count = dser.getInt();
			this.ops = new java.util.ArrayList<Op>(count);
			for (int i = 0; i < count; ++i) {
				this.ops.add(dser.getOp());
			}
			if (!dser.isDone()) {
				throw new RuntimeException("Trailing garbage at end of deserialized HSPProgram");
			}
			return this;
		}

		public static LinkedList<Op>
		makeAnalyze(String lang, String prefix, FormalPredicate pred, AbstractTuple targets, DatalogProjectionSink psink) {
			if (!lang.equals("java8")) {
				throw new RuntimeException("Unsupported language");
			}
			LinkedList<Op> list = new LinkedList<Op>();
			addTypeInfo(list, pred);
			HFPProgram.addLoadAbstractTuple(list, pred, targets);

			java.util.List<FormalPredicate> sink_predicates = psink.predicates();
			final int HEADER_SIZE = HFPProgram.ANALYZE_HEADER_SIZE;
			String args[] = new String[HEADER_SIZE + sink_predicates.size()];
			args[ANALYZE_LANG] = lang;
			args[ANALYZE_PREFIX] = prefix;
			args[ANALYZE_PREDICATE] = pred.getPRED_ID();
			for (int i = 0; i < sink_predicates.size(); ++i) {
				final FormalPredicate sink_pred = sink_predicates.get(i);
				String name = "";
				if (sink_pred != null) {
					name = sink_pred.getPRED_ID();
				} else {
					System.err.println("Warning: unknown predicate for Java->SWIG sink at " + i + "; not binding");
				}
				args[i + HEADER_SIZE] = name;
			}
			list.add(Op.make(HFPProgram.ANALYZE, args));
			return list;
		}

		public static void
		addLoadAbstractTuple(LinkedList<Op> list, FormalPredicate pred, AbstractTuple tuple) {
			addTypeInfo(list, pred);
			for (AITuple tup : tuple.concreteTuples()) {
				HFPProgram.addAddTuple(list, pred, tup);
			}
			for (AbstractTuple.SourceInfo filesource : tuple.fileSources()) {
				HFPProgram.addLoad(list, pred, filesource.getFileSource(), filesource.getFormat());
			}
		}

		public static void
		addAddTuple(LinkedList<Op> list, FormalPredicate pred, AITuple elements) {
			addTypeInfo(list, pred);
			String[] args = new String[ADDTO_HEADER_SIZE + elements.size()];
			args[ADDTO_PREDICATE] = pred.getPRED_ID();
			for (int i = 0; i < elements.size(); ++i) {
				// Only String types supported right now; need to extend
				// serialisation scheme for non-strings, e.g., by
				// prefixing type information for supported types
				args[i + ADDTO_HEADER_SIZE] = (String) elements.get(i);
			}
			list.add(Op.make(HFPProgram.ADDTO, args));
		}

		public static void
		addTypeInfo(LinkedList<Op> list, FormalPredicate pred) {
			PredicateType ty = pred.type();
			String[] typeinfo = new String[PREDICATE_TYPE_HEADER_SIZE + ty.arity()];
			typeinfo[PREDICATE_TYPE_PREDICATE] = pred.getPRED_ID();
			for (int i = 0; i < ty.arity(); ++i) {
				typeinfo[PREDICATE_TYPE_HEADER_SIZE + i] = ty.get(i).toString();
			}
			list.add(Op.make(HFPProgram.PREDICATE_TYPE, typeinfo));
		}

		public static void
		addLoad(LinkedList<Op> list, FormalPredicate pred, String filename, String format) {
			addTypeInfo(list, pred);
			list.add(Op.make(HFPProgram.LOAD, null, pred.getPRED_ID(), filename, format));
		}

		public Iterable<String>
		getFormalPredicates() {
			ArrayList<String> retval = new ArrayList<String>();
			for (int i = 1; i < this.formal_predicates.body.length; ++i) {
				retval.add(this.formal_predicates.body[i]);
			}
			return retval;
		}

		public static HFPProgram
		make(Iterable<FormalPredicate> formal_predicates, java.util.List<HFPProgram.Op> ops) {
			if (ops == null) {
				return null;
			}
			HFPProgram prog = new HFPProgram();
			ArrayList<String> formal_preds = new ArrayList<String>();
			for (FormalPredicate fp : formal_predicates) {
				formal_preds.add(fp.getPRED_ID());
			}
			String[] formal_pred_strings = new String[1 + formal_preds.size()];
			formal_preds.toArray(formal_pred_strings);
			System.arraycopy(formal_pred_strings, 0,
					 formal_pred_strings, 1,
					 formal_pred_strings.length - 1);
			formal_pred_strings[0] = null;
			prog.formal_predicates = Op.make(DECL, formal_pred_strings);

			prog.ops = new ArrayList<>(ops);
			prog.sortOps();
			return prog;
		}

		public void
		sortOps() {
			Collections.sort(this.ops);

			// remove dupes
			int index = 0;
			while (index < this.ops.size() - 1) {
				Op op0 = this.ops.get(index);
				Op op1 = this.ops.get(index + 1);
				if (op0.compareTo(op1) == 0) {
					this.ops.remove(index);
				} else {
					++index;
				}
			}
		}

		public Runner
		runner(Map<String, TupleInserter> tuple_inserters, CmdLineOpts opts) {
			return new Runner(new EvaluationContext(), tuple_inserters, opts);
		}

		public void
		run(Map<String, TupleInserter> fpToSoufflePredMap, CmdLineOpts opts) throws IOException, SQLException {
			Runner runner = this.runner(fpToSoufflePredMap, opts);
			runner.runUntil(null);
		}

		@Override
		public String
		toString() {
			StringBuffer buf = new StringBuffer();
			buf.append("HFP:decl\n");
			buf.append("  annotations: ");
			buf.append(this.annotations);
			buf.append('\n');
			buf.append("  formal_pred: ");
			buf.append(this.formal_predicates);
			buf.append('\n');
			buf.append("  cached_pred: ");
			buf.append(this.cached_predicates);
			buf.append('\n');
			buf.append("HFP:start\n");
			for (HFPProgram.Op op : this.ops) {
				buf.append("  ");
				buf.append(op);
				buf.append("\n");
			}
			buf.append("HFP:end\n");
			return buf.toString();
		}

		// Command pattern
		private static abstract class Action {
			private static HashMap<String, Action> actions = new HashMap<String, Action>();

			public String marker;
			public Action(String marker) {
				this.marker = marker;
				Action.actions.put(marker, this);
			};

			public static Action
			getAction(String action_marker) {
				Action action = Action.actions.get(action_marker);
				if (action == null) {
					throw new RuntimeException("Unknown action '" + action_marker + "'");
				}
				return action;
			}

			// args[0] is always the name of the action
			public abstract void run(Runner pstate, String[] args) throws IOException, SQLException;
		}

		static final int ANALYZE_HEADER_SIZE = 4;
		static final int ANALYZE_LANG = 1;
		static final int ANALYZE_PREFIX = 2;
		static final int ANALYZE_PREDICATE = 3;

		// Analyze is the only action with a lower case marker
		protected static final class Analyze extends Action {
			public Analyze() {
				super("a");
			}

			public void run(Runner pstate, String[] args) throws IOException, SQLException {
				final String lang = args[ANALYZE_LANG];
				final String pred_name = args[ANALYZE_PREDICATE];

				if (!lang.equals("java8")) {
					throw new RuntimeException("Unsupported language: " + lang);
				}

				// Prepare output sink
				ArrayList<TupleInserter> inserters = new ArrayList<>();
				for (int i = ANALYZE_HEADER_SIZE; i < args.length; ++i) {
					if (args[i].equals("")) {
						// Not used in source program, we already warned
						// when translating into HFP
						inserters.add(TupleInserter.NULL);
						continue;
					}
					TupleInserter inserter = pstate.souffle_pred_map.get(args[i]);
					if (inserter == null) {
						System.err.println("Warning: could not bind predicate '" + args[i] + "' to SWIG");
						inserter = TupleInserter.NULL;
					}
					inserters.add(inserter);
				}

				DatalogProjectionSink tupleSink =
					DatalogProjectionSink.fromInserters(pstate.ctx,
									    inserters);

				// Collect source files
				RelationWrapper sources_wrapped = pstate.getRelationWrapper(pred_name);
				java.util.List<String> sources = new ArrayList<>();
				for (RelationWrapper.TupleWrapper t : sources_wrapped.tuples()) {
					sources.add(t.getAsString(0));
				}

				// And load sources
				FileUtil.loadJavaSources(pstate.ctx,
							 tupleSink,
							 sources);
			}

		}

		/**
		 * Analyze input files
		 */
		public static final Action ANALYZE = new Analyze();

		static final int ADDTO_HEADER_SIZE = 2;
		static final int ADDTO_PREDICATE = 1;

		// Assign tuple to predicate
		private static final Action ADDTO = new Action("T") {
				public void run(Runner pstate, String[] args) {
					throw new RuntimeException("FIXME: ADDTO");
				}
			};


		static final int LOAD_HEADER_SIZE = 4;
		static final int LOAD_PRED = 1;
		static final int LOAD_SOURCE_FILE = 2;
		static final int LOAD_FORMAT = 3;
		// Load from file
		private static final Action LOAD = new Action("L") {
				public void run(Runner pstate, String[] args) throws IOException, SQLException {
					final String pred = args[LOAD_PRED];
					final String source_file = args[LOAD_SOURCE_FILE];
					final String format = args[LOAD_FORMAT];
					Program.loadEDB(pred, pstate.relation(pred), pstate.type(pred),
							source_file, format, pstate.ctx, pstate.opts);
				}
			};

		// Numeric actions come first
		// General metainformation
		private static final Action DECL = new Action("0") {
				public void run(Runner pstate, String[] args) {
					// no-op
				}
			};

		static final int PREDICATE_TYPE_HEADER_SIZE = 2;
		static final int PREDICATE_TYPE_PREDICATE = 1;

		// defines a predicate type
		private static final Action PREDICATE_TYPE = new Action("1") {
				public void run(Runner pstate, String[] args) {
					final String pred = args[PREDICATE_TYPE_PREDICATE];
					Type[] types = new Type[args.length - PREDICATE_TYPE_HEADER_SIZE];
					for (int i = 0; i < args.length - PREDICATE_TYPE_HEADER_SIZE; ++i) {
						String tyname = args[i + PREDICATE_TYPE_HEADER_SIZE];
						types[i] = TYPES.get(tyname);
						if (types[i] == null) {
							throw new RuntimeException("Unknown type at index " + i + " for " + this);
						}
					}
					pstate.local_types.put(pred, new PredicateType(types));
				}
			};

		public static class Op implements Comparable<Op> {
			public String[] body;
			private Action action = null;

			public Action
			getAction() {
				if (this.action == null) {
					this.action = Action.getAction(this.body[0]);
				}
				return this.action;
			}

			public void
			run(Runner pstate) throws IOException, SQLException {
				this.getAction().run(pstate, this.body);
			}

			private Op() {}

			public static Op
			make(String ...args) {
				Op op = new Op();
				op.body = args;
				return op;
			}

			/**
			 * args[0] must be null, will automatically be filled with action.marker
			 */
			public static Op
			make(Action action, String ...args) {
				Op op = new Op();
				op.action = action;
				op.body = args;
				op.body[0] = action.marker;
				return op;
			}

			public int
			compareTo(Op other) {
				// first by the operator
				String atobj = this.body[0];
				String aoobj = other.body[0];
				int adiff = atobj.compareTo(aoobj);
				if (adiff != 0) {
					return adiff;
				}

				// second by length
				int ldiff = this.body.length - other.body.length;
				if (ldiff != 0) {
					return ldiff;
				}

				// third by the parameters
				for (int i = 1; i < this.body.length; ++i) {
					String tobj = this.body[i];
					String oobj = other.body[i];
					int diff = tobj.compareTo(oobj);
					if (diff != 0) {
						return diff;
					}
				}
				return 0;
			}

			public void
			serialize(StringBuffer sb) {
				serializeNonnegativeInt(sb, this.body.length);
				for (String s : this.body) {
					serializeString(sb, s);
				}
			}

			public Op
			deserialize(Deserializer dser) {
				int count = dser.getInt();
				this.body = new String[count];
				for (int i = 0; i < count; ++i) {
					this.body[i] = dser.getString();
				}
				return this;
			}

			@Override
			public String
			toString() {
				StringBuffer buf = new StringBuffer(body[0]);
				buf.append("(");
				for (int i = 1; i < this.body.length; ++i) {
					if (i > 1) {
						buf.append(", ");
					}
					buf.append(this.body[i]);
				}
				buf.append(")");
				return buf.toString();
			}
		}

		private static final int SERIALIZATION_MASK = 0x3f;
		private static final int SERIALIZATION_SHIFT = 6;

		/**
		 * Serialisation and deserialisation helper
		 */
		static class Deserializer {
			int offset = 0;
			CharBuffer buf;

			public Deserializer(CharBuffer buf) {
				this.buf = buf;
			}

			public int
			getInt() {
				final int MASK = SERIALIZATION_MASK;
				final int SHIFT = SERIALIZATION_SHIFT;

				char c = this.buf.get();
				int result = 0;
				while (c != '#') {
					result <<= SHIFT;
					result |= (((int)c) - ((int)'0')) & MASK;
					c = this.buf.get();
				}
				return result;
			}

			public void
			expect(String code) {
				final char[] characters = new char[code.length()];
				this.buf.get(characters);
				String actual = new String(characters);
				if (!code.equals(actual)) {
					throw new RuntimeException("Error while decoding: expected '"+code+"' but read '"+actual+"'");
				}

			}

			public String
			getString() {
				int size = getInt();
				final char[] characters = new char[size];
				this.buf.get(characters);
				return new String(characters);
			}

			public Op
			getOp() {
				return (new Op()).deserialize(this);
			}

			public HFPProgram
			getProgram() {
				return (new HFPProgram()).deserialize(this);
			}

			public boolean
			isDone() {
				return this.buf.position() >= this.buf.length();
			}
		}

		private static final void
		serializeNonnegativeInt(StringBuffer sb, int i) {
			final int MASK = SERIALIZATION_MASK;
			final int SHIFT = SERIALIZATION_SHIFT;
			int bufpos = 0;
			char[] buf = new char[16];

			// must reverse order
			while (i > 0) {
				char c = (char) (((int)'0') + (i & MASK));
				buf[bufpos++] = c;
				i >>= SHIFT;
			}
			for (i = bufpos - 1; i >= 0; --i) {
				sb.append(buf[i]);
			}
			sb.append('#');
		}

		private static final void
		serializeString(StringBuffer sb, String s) {
			serializeNonnegativeInt(sb, s.length());
			sb.append(s);
		}

		// Evaluation state
		public final class Runner {
			EvaluationContext ctx;
			HashMap<String, Relation2> local_predicates = new HashMap<>();
			HashMap<String, PredicateType> local_types = new HashMap<>();
			Map<String, TupleInserter> souffle_pred_map;
			CmdLineOpts opts;

			private int pos = 0;

			public RelationWrapper
			getRelationWrapper(String pred_name) {
				final Relation2 pred_rel2 = this.relation(pred_name);
				final PredicateType pred_type = this.type(pred_name);
				return new RelationWrapper(this.ctx,
							   pred_rel2, pred_type);
			}

			public Relation2
			relation(String pred) {
				Relation2 rel = local_predicates.get(pred);
				if (rel == null) {
					PredicateType type = this.type(pred);
					if (type == null) {
						System.err.println("Error in Runner for HFPProgram:\n" + HFPProgram.this);
						System.err.println(this.local_types);
						throw new RuntimeException("Can't create relation for '" + pred + "' because we lack type information");
					}
					rel = new Relation2(type.arity());
					local_predicates.put(pred, rel);
				}
				return rel;
			}

			public PredicateType
			type(String pred) {
				return this.local_types.get(pred);
			}

			public boolean
			isDone() {
				return this.pos >= HFPProgram.this.ops.size();
			}

			/**
			 * Execute one step
			 */
			public void
			step() throws IOException, SQLException {
				Op op = HFPProgram.this.ops.get(this.pos++);
				op.run(this);
			}

			/**
			 * Execute one step, unless the next step would be an ANALYZE (AnalyzeBlock).
			 *
			 * In the latter case it returns AnalyzeInfo instead and expects the caller to handle
			 * the relevant processing.
			 */
			public AnalyzeInfo
			stepOverAnalyze() throws IOException, SQLException {
				Op op = HFPProgram.this.ops.get(this.pos);
				if (op.getAction() == ANALYZE) {
					this.pos++;
					return new AnalyzeInfo(op, this);
				} else {
					op.run(this);
				}
				return null;
			}

			public Op
			getNextOp() {
				if (this.isDone()) {
					return null;
				}
				return HFPProgram.this.ops.get(this.pos);
			}

			/**
			 * Execute until either done or the next step is an action of the specified type
			 *
			 * Type 'null' allows running to the end
			 */
			public void
			runUntil(Action action) throws IOException, SQLException {
				while (!this.isDone()
				    && (action == null
					|| getNextOp().getAction() != action)) {
					step();
				}
			}

			public Runner(EvaluationContext ctx, Map<String, TupleInserter> souffle_pred_map, CmdLineOpts opts) {
				this.ctx = ctx;
				this.opts = opts;
				this.souffle_pred_map = souffle_pred_map;
			}
		}

		public class AnalyzeInfo {
			private Op op;
			private Runner runner;

			AnalyzeInfo(Op op, Runner runner) {
				this.runner = runner;
				this.op = op;
			}

			public String
			getPrefix() {
				return this.op.body[ANALYZE_PREFIX];
			}

			public String
			prefix(String pred) {
				return this.getPrefix() + pred;
			}
		}


		public static HashMap<String, Type> TYPES = new HashMap<>();
		static {
			for (Type ty : new Type[] {
					ASTNodeType.get(),
					IntegerType.get(),
					StringType.get(),
					PredicateRefType.get(),
					UnknownType.get()
				}) {
				TYPES.put(ty.name(), ty);
			}
		}

	}


	/**
	 * Derives a HFPProgram, if possible, otherwise null
	 */
	syn HFPProgram Program.getHFPProgram() {
		ArrayList<HFPProgram.Op> ops = new ArrayList<>();
		for (CommonClause c : this.getCommonClauseList()) {
			LinkedList<HFPProgram.Op> additions = c.getHFP();
			if (additions == null) {
				System.out.println("Hybrid Fast Path (HFP) construction failed (optimisation disabled) for:\n  " + c);
				return null;
			}
			ops.addAll(additions);
		}
		return HFPProgram.make(this.getFormalPredicates(), ops);
	}

	/**
	 * HFPops to run, or null if not supported
	 */
	syn LinkedList<HFPProgram.Op> CommonClause.getHFP() = null;

	eq Clause.getHFP() {
		LinkedList<HFPProgram.Op> list = new LinkedList<>();
		if (AITruth.TOP == this.aiBodySatisfied()) {
			return null;
		}
		for (CommonLiteral hlit : this.getHeadsList()) {
			LinkedList<HFPProgram.Op> subops = hlit.getHFPasHead();
			if (subops == null) {
				return null;
			}
			list.addAll(subops);
		}
		return list;
	}

	eq AnalyzeBlock.getHFP() {
		Object lang_o = this.getLang().aiValue();
		if (!(lang_o instanceof String)) {
			return null;
		}
		String lang = (String) lang_o;
		AbstractTuple targets = this.getProgramRef().aiTuple();
		if (AbstractTuple.TOP == targets) {
			return null;
		}
		return HFPProgram.makeAnalyze(lang,
					      this.getContext().scopePrefix,
					      this.getProgramRef().formalpredicate(),
					      targets,
					      program().getDatalogProjectionSink(this));
	}

	syn LinkedList<HFPProgram.Op> CommonLiteral.getHFPasHead() {
		if (this.aiPredicateRefContribution() == null
		    && this.aiTuple() == null) {
			return null; // Can't tell what to do with them
		}
		return new LinkedList<HFPProgram.Op>(); // Leave it to the AnalyzeBlocks to track their dependencies
	}
}

