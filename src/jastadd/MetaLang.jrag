import lang.cons.Constraint;
import java.io.StringReader;


aspect MetaLang {
	/**
	   enclosingAnalyzeBlock - the enclosing analyze block if it exists
	 */
	inh AnalyzeBlock CommonClause.enclosingAnalyzeBlock();
	inh AnalyzeBlock PredicateSymbol.enclosingAnalyzeBlock();
	inh AnalyzeBlock CommonLiteral.enclosingAnalyzeBlock();
	inh AnalyzeBlock Pattern.enclosingAnalyzeBlock();
	inh AnalyzeBlock PredicateRef.enclosingAnalyzeBlock();

	eq Program.getCommonClause().enclosingAnalyzeBlock() = null;
	eq AnalyzeBlock.getClause().enclosingAnalyzeBlock() = this;
	eq AnalyzeBlock.getExpandedClause().enclosingAnalyzeBlock() = this;

	syn String ASTNode.getScopePrefix() = getParent().getScopePrefix();
	eq Program.getScopePrefix() = "";
    eq AnalyzeBlock.getScopePrefix() = "A_" + getProgramRef().getPRED_ID() + "_";
	syn AnalyzeContext AnalyzeBlock.getContext() {
		return new AnalyzeContext(getScopePrefix(), getProgramRef().getPRED_ID());
	}

	syn nta List<Clause> AnalyzeBlock.getExpandedClauseList() {
		List<Clause> cls = new List<>();
		cls.addAll(lang.metadl.pat.ast.PatLang.generateHelperRelations(getContext()));
		for (Clause c : getClauses())
			cls.add(c.treeCopy());
		return cls;
	}

	AnalyzeBlock contributes nta getExpandedClauses() to Program.predicateSymbols();

	rewrite PredicateSymbol {
		when (enclosingAnalyzeBlock() != null &&
			  lang.metadl.pat.ast.PatLang.translatePredicateName(enclosingAnalyzeBlock().getContext(), getPRED_ID()) != null)
			to PredicateSymbol {
			return new PredicateSymbol(lang.metadl.pat.ast.PatLang.translatePredicateName(enclosingAnalyzeBlock().getContext(),
																				  getPRED_ID()));
		}
	}

	rewrite PredicateRef {
		when (enclosingAnalyzeBlock() != null &&
			  lang.metadl.pat.ast.PatLang.translatePredicateName(enclosingAnalyzeBlock().getContext(), getPRED_ID()) != null)
			to PredicateRef {
			return new PredicateRef(lang.metadl.pat.ast.PatLang.translatePredicateName(enclosingAnalyzeBlock().getContext(),
																			   getPRED_ID()));
		}
	}

	syn nta List<Literal> Pattern.getLiterals() {
		List<Literal> literals = new List<>();
		literals.addAll(patternAST().literals(enclosingAnalyzeBlock().getContext(), null));
		return literals;
	}

	syn nta List<Literal> BoundedPattern.getLiterals() {
		List<Literal> literals = new List<>();
		literals.addAll(patternAST().literals(enclosingAnalyzeBlock().getContext(), getCommonVariable()));
		return literals;
	}

	syn lang.metadl.pat.ast.ASTNode Pattern.patternAST() {
		lang.metadl.pat.ast.ASTNode node = null;

		short[] AltGoals = new short[]{
			lang.metadl.pat.ast.PatLangParser.AltGoals.clause,
			lang.metadl.pat.ast.PatLangParser.AltGoals.common_literal,
			lang.metadl.pat.ast.PatLangParser.AltGoals.expr
		};

		java.util.List<Exception> exceptions = new java.util.ArrayList<>();

		ByteArrayOutputStream errStream = new ByteArrayOutputStream();


		// Try all the goals until one succeeds. Also collect the errors to report them
		// in case none of the parsing attempts is successful.
		for (short g : AltGoals) {
			try {
				lang.metadl.pat.ast.LangScanner scanner = new lang.metadl.pat.ast.LangScanner(new StringReader(getPATTERN()));
				lang.metadl.pat.ast.PatLangParser parser = new lang.metadl.pat.ast.PatLangParser();
				// the parsers writes directly to System.err so we capture it
				PrintStream oldErr = System.err;
				System.setErr(new PrintStream(errStream));
				node = (lang.metadl.pat.ast.ASTNode) parser.parse(scanner, g);
				System.setErr(oldErr);
				break;
			} catch (Exception e) {
				exceptions.add(e);
			}
		}

		if (node == null) {
			// None of the parsing attempts succeeded. Print the errors
			for (Exception e : exceptions)
				SimpleLogger.logger().log("Error while parsing pattern: " + getPATTERN() + "\n" + e.toString());
			System.out.println(errStream.toString());
			System.exit(1);
		}

		return node;
	}

	eq Pattern.variables() {
		return patternAST().metavariables();
	}

	eq BoundedPattern.variables() {
		TreeSet<lang.ast.Variable> vars = new TreeSet<>(lang.ast.Term.termComparator);
		vars.addAll(patternAST().metavariables());
		vars.add((Variable)getCommonVariable());
		return vars;
	}

	eq Pattern.isInclusive() = true;

	public class AnalyzeContext {
		public String scopePrefix;
		public String progRelName;

		public AnalyzeContext(String scopePrefix, String progRelName) {
			this.scopePrefix = scopePrefix;
			this.progRelName = progRelName;
		}
	}
}
