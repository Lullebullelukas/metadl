aspect MetaLang {
	/**
	  enclosingPattern - return the enclosing pattern if it exists, otherwise null
	 */
	inh ClausePattern CommonClause.enclosingPattern();
	inh ClausePattern ClausePattern.enclosingPattern();
	inh ClausePattern TermGap.enclosingPattern();
	inh ClausePattern LiteralGap.enclosingPattern();

	eq ClausePattern.getClause().enclosingPattern() = this;
	eq Program.getCommonClause().enclosingPattern() = null;

	/**
	   enclosingAnalyzeBlock - the enclosing analyze block if it exists
	 */
	inh AnalyzeBlock CommonClause.enclosingAnalyzeBlock();
	inh AnalyzeBlock ClausePattern.enclosingAnalyzeBlock();
	eq AnalyzeBlock.getClause().enclosingAnalyzeBlock() = this;
	eq Program.getCommonClause().enclosingAnalyzeBlock() = null;

	syn String ASTNode.varName() {
		String nodeNameFull = this.getClass().getName();
		String[] splitNodeName = nodeNameFull.split("\\.");
		String nodeName = splitNodeName[splitNodeName.length - 1];
		return "v_" + getNodeId() + "_" + nodeName;
	}

	/**
	   The asLiterals() equations are isomorphic to buildTupleWrapper()
	   equtions in the DatalogProject aspect. The common parts should be
	   factored out to ensure that the relational
	   representation of a program matches the code generated for a pattern.
	 */
	syn List<Literal> ASTNode.asLiterals();

	eq ASTNode.asLiterals() {
		List<Literal> literals = new List<>();

		int childIndex = 0;

		for (int i = 0; i < getNumChild(); ++i) {
			ASTNode child = getChild(i);
			if (child instanceof Opt)
				continue;
			if (child instanceof List) {
				List<ASTNode> childrenList  = (List<ASTNode>) child;
				for (ASTNode c : childrenList) {
					List<Term> terms = new List<>();
					terms.add(new Variable(varName()));
					terms.add(new IntConstant("" + childIndex++));
					terms.add(new Variable(c.varName()));
					literals.add(new Atom(new PredicateSymbol(getRelation()), terms));
				}
			} else {
				List<Term> terms = new List<>();
				terms.add(new Variable(varName()));
				terms.add(new IntConstant("" + childIndex++));
				terms.add(new Variable(getChild(i).varName()));
				literals.add(new Atom(new PredicateSymbol(getRelation()), terms));
			}
		}
		return literals;
	}

	eq Rule.asLiterals() {
		List<CommonLiteral> heads = getHeadss();
		List<CommonLiteral> bodys = getBodys();

		List<Literal> literals = new List<>();
		int childIndex = 0;
		for (ASTNode h : heads) {
			List<Term> terms = new List();
			terms.add(new Variable(varName()));
			terms.add(new IntConstant("" + childIndex++));
			terms.add(new Variable(h.varName()));
			literals.add(new Atom(new PredicateSymbol("Head"), terms));
		}
		childIndex = 0;
		for (ASTNode b : bodys) {
			List<Term> terms = new List();
			terms.add(new Variable(varName()));
			terms.add(new IntConstant("" + childIndex++));
			terms.add(new Variable(b.varName()));
			literals.add(new Atom(new PredicateSymbol("Body"), terms));
		}
		return literals;
	}

	eq Constant.asLiterals() {
		PredicateSymbol pred = new PredicateSymbol(getRelation());
		List<Literal> literals = new List<>();
		List<Term> terms = new List<>();
		terms.add(new Variable(varName()));
		terms.add(this.fullCopy());
		literals.add(new Atom(pred, terms));
		return literals;
	}

	eq Variable.asLiterals() {
		PredicateSymbol pred = new PredicateSymbol(getRelation());
		List<Literal> literals = new List<>();
		List<Term> terms = new List<>();
		terms.add(new Variable(varName()));
		terms.add(new StringConstant(this.getVAR_ID()));
		literals.add(new Atom(pred, terms));
		return literals;
	}

	eq MetaAtom.asLiterals() {
		Variable pred = new Variable(getPredicate().varName());
		String atomRelName = new Atom().getRelation();
		// Atom(atom_id, 0, pred_id)
		List<Literal> literals = new List<>();
		List<Term> terms = new List<>();
		terms.add(new Variable(varName()));
		terms.add(new IntConstant("0"));
		terms.add(pred);
		PredicateSymbol predAtom = new PredicateSymbol(atomRelName);
		literals.add(new Atom(predAtom, terms));
		for (int i = 0; i < getNumTerm(); ++i) {
			terms = new List<>();
			terms.add(new Variable(varName()));
			terms.add(new IntConstant("" + (i + 1)));
			terms.add(new Variable(getTerm(i).varName()));
			literals.add(new Atom(predAtom, terms));
		}
		return literals;
	}

	syn nta MetaVariable CommonLiteral.indexVar() {
		if (hasIndex())
			return getIndex().fullCopy();
		else
			return new MetaVariable("i_" + getNodeId());
	}

	inh boolean Term.parentIsMetaVar();
	eq Term.getChild().parentIsMetaVar() = false;
	eq MetaVariable.getIndex().parentIsMetaVar() = true;

	syn nta MetaVariable Term.indexVar() {
		// Avoid creating infinite chains of MetaVariables
		// with MetaVariable indices...
		if (parentIsMetaVar())
			return null;
		if (hasIndex())
			return getIndex().fullCopy();
		else
			return new MetaVariable("i_" + getNodeId());
	}

	syn boolean ASTNode.isGap() = false;
	eq LiteralGap.isGap() = true;
	eq TermGap.isGap() = true;

	eq MetaVariable.asLiterals() {
		return new List<>();
	}

	eq List.asLiterals() = new List<>();
	eq Opt.asLiterals() = new List<>();

	eq ClausePattern.asLiterals() = new List<>();
	eq MetaVariable.varName() = "mv_" + getMETAVAR_ID();

	// Collect all the literals resulting from a ClausePattern
	ASTNode contributes asLiterals() to ClausePattern.literals();
	coll List<CommonLiteral> ClausePattern.literals() with addAll root ClausePattern;
	// Collect all the variables resulting from a ClausePattern
	MetaVariable contributes varName() to ClausePattern.metaVariables();
	Term contributes nta indexVar() to ClausePattern.metaVariables();
	CommonLiteral contributes nta indexVar() to ClausePattern.metaVariables();
	coll TreeSet<String> ClausePattern.metaVariables() root ClausePattern;

	syn Clause ClausePattern.asClause() {
		String predicateName = "CP_" + getNodeId();
		List<Term> vars = new List<>();
		for (String vname : metaVariables()) {
			vars.add(new Variable(vname));
		}

		Atom headAtom = new Atom(new PredicateSymbol(predicateName), vars);
		return new Rule(new List(headAtom),
						literals());
	}

	syn List<Literal> Fact.toDatalog() {
		return null;
	}

	syn List<Literal> Rule.toDatalog() {
		return null;
	}


}
