import org.apache.commons.collections4.MultiValuedMap;
import org.apache.commons.collections4.multimap.ArrayListValuedHashMap;


aspect EquivalencePatterns {
	inh AnalyzeBlock EquivalenceDecl.enclosingAnalyzeBlock();

	syn lazy MultiValuedMap<String, EquivalenceDecl> AnalyzeBlock.equivalenceLabelDecls() {
		MultiValuedMap<String, EquivalenceDecl> label2decl = new ArrayListValuedHashMap<>();
		for (EquivalenceDecl eDecl : getEquivalenceDecls()) {
			label2decl.put(eDecl.getLABEL(), eDecl);
		}

		return label2decl;
	}

	syn lazy java.util.List<Clause> EquivalencePatternDecl.getClauses() {
		/* TODO: Generate a new predicate that represents all the equivalent patterns */
		
		return Collections.emptyList();
	}

	@Override public java.util.List<Clause> EquivalencePattern.getClausesHelper(CommonVariable bindVar) {
		if (bindVar != null) {
			throw new RuntimeException("Rooted equivalence patterns are not supported for now");
		}

		
		
		Collection<EquivalenceDecl> equivalenceDecls = enclosingAnalyzeBlock()
		.equivalenceLabelDecls().get(getLABEL());
		
		AnalyzeContext ctx = enclosingAnalyzeBlock().getContext();
		ArrayList<Clause> ret = new ArrayList<>();

		for (ObjLangASTNode n : altParse()) {
			Literal head = getLiteralHelper(bindVar);
			Rule r = new Rule(new List<CommonLiteral>().add(head),
							  new List<CommonLiteral>().addAll(n.literals(ctx,bindVar)));
			ret.add(r);
		}
		/*
		  TODO: generate clauses for this pattern
		*/
		return ret;
	}

	@Override protected Literal EquivalencePattern.getLiteralHelper(CommonVariable bindVar) {
		if (bindVar != null) {
			throw new RuntimeException("Rooted equivalence patterns are not supported for now");
		}

		List<Term> headVars = new List<>();
		ObjLangASTNode n = altParse().iterator().next();
		for (Variable v : n.metavariables())
			headVars.add(v.treeCopy());
		/*
		  TODO: generate a literal that represents the equivalence
		 */
	
		return new Literal(new PredicateSymbol("Equiv_Pattern_" + getLABEL()), 
							headVars);
	}


	syn nta Literal EquivalencePattern.getLiteral() {
		Literal l = getLiteralHelper(null);
		if(hasNot())
			l.setNot(new Not());
		return l;
	}


	/* For now, don't allow multiple equivalence declarations to share the same label */
	EquivalenceDecl contributes new SemanticError(this, "Multiple equivalence declarations with the same label: " + this.getLABEL())
		when (enclosingAnalyzeBlock() != null && enclosingAnalyzeBlock().equivalenceLabelDecls().get(getLABEL()).size() != 1) to Program.semanticErrors();
}
